<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GNSS Viewer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        :root { --header-height: 60px; --tab-height: 40px; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; background: #f0f2f5; }
        .header { background: #2c3e50; color: white; padding: 0 20px; height: var(--header-height); display: flex; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex-shrink: 0; z-index: 20; }
        .header h1 { flex-grow: 1; font-size: 1.5em; }
        .header .header-buttons { margin-left: auto; display: flex; align-items: center; gap: 10px; }
        .header .header-buttons button { background: #3498db; color: white; border: none; border-radius: 5px; padding: 8px 12px; font-size: 0.9em; cursor: pointer; white-space: nowrap; }
        .header .header-buttons button:hover { background: #2980b9; }
        .header #helpBtn { background: #95a5a6; border-radius: 50%; width: 32px; height: 32px; font-size: 1.4em; font-weight: bold; padding: 0; }
        .header #helpBtn:hover { background: #7f8c8d; }

        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; height: calc(100% - var(--header-height) - 40px); }
        .left-panel { width: 60%; display: flex; flex-direction: column; background: #ecf0f1; border-right: 2px solid #bdc3c7; }
        .right-panel { width: 40%; display: flex; flex-direction: column; }
        
        .tab-bar { flex-shrink: 0; display: flex; background-color: #ecf0f1; border-bottom: 2px solid #bdc3c7; }
        .tab-button { padding: 0 15px; height: var(--tab-height); border: none; background: #ecf0f1; cursor: pointer; font-size: 0.9em; color: #7f8c8d; border-bottom: 3px solid transparent; }
        .tab-button.active { background: #fff; color: #2c3e50; font-weight: bold; border-bottom: 3px solid #3498db; }
        .tab-content { flex-grow: 1; position: relative; background: #fff;}
        .tab-pane { width: 100%; height: 100%; position: absolute; visibility: hidden; opacity: 0; transition: opacity 0.2s; }
        .tab-pane.active { visibility: visible; opacity: 1; }
        #map { width: 100%; height: 100%; }
        #plot-container-wrapper { display: flex; flex-direction: column; height: 100%; }
        #plot-controls { padding: 8px; background: #f8f9fa; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; font-size: 0.85em; }
        #plot-controls label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        #plot-controls select, #plot-controls input[type="number"] { padding: 4px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; }
        #plot-controls button { padding: 4px 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; cursor: pointer; }
        #plot-controls button:disabled { background-color: #e0e0e0; cursor: not-allowed; }
        #plot-controls button.active { background: #3498db; color: white; border-color: #2980b9; }
        #section-controls-group { display: flex; gap: 8px; align-items: center; }
        #plot-canvas-container { flex-grow: 1; position: relative; padding: 10px; }
        #xyPlot.crosshair { cursor: crosshair; }
        #xyPlot.editable-section { cursor: pointer; }

        .info-panel { padding: 10px 15px; background: #fff; margin: 10px 10px 0 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); flex-shrink: 0; }
        
        .compact-controls { display: grid; grid-template-columns: repeat(3, auto) 1fr 1fr repeat(2, auto); gap: 8px; margin-bottom: 10px; align-items: end;}
        
        .control-group { display: flex; flex-direction: column; }
        .control-group label { font-size: 0.8em; margin-bottom: 2px; color: #555; font-weight: bold; }
        .control-group input, .control-group select, .control-group button { padding: 8px; background: #fff; border-radius: 4px; border: 1px solid #ccc; font-size: 0.9em; width: 100%; }
        .control-group button { background-color: #3498db; color: white; border: none; cursor: pointer; text-align: center;}
        
        .compact-controls .control-group button { width: auto; white-space: nowrap; padding-left: 12px; padding-right: 12px; }
        .control-group button:hover { background-color: #2980b9; }
        
        #tableContainer { flex-grow: 1; overflow-y: auto; margin: 10px; border: 1px solid #ccc; }
        table { width: 100%; border-collapse: collapse; background: white; font-size: 0.8em; }
        thead { position: sticky; top: 0; background: #34495e; color: white; z-index: 10; }
        th, td { padding: 8px 10px; text-align: left; border: 1px solid #ddd; white-space: nowrap; }
        .drag-handle { cursor: move; user-select: none; width: 20px; text-align: center; }
        tbody tr:nth-child(even) { background-color: #f8f9fa; }
        tbody tr.highlighted { background-color: #aed6f1 !important; }
        tbody tr.in-section { background-color: #e8dff5 !important; font-weight: bold; }
        tbody tr.sortable-ghost { background: #c8ebfb; }
        td.editable-cell:hover { background-color: #fffacd; cursor: text; }
        td.editable-cell input { width: 100%; border: 1px solid #3498db; outline: none; padding: 6px; box-sizing: border-box; font-size: 1em; }
        td.modified-cell { background-color: #e0f7fa; }
        td.modified-cell > strong::after { content: " âœï¸"; font-size: 0.8em; display: inline-block; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 80%; max-width: 900px; height: 80%; max-height: 600px; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 15px; }
        .modal-header .button-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: flex-end; }
        .modal-header button { padding: 4px 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; cursor: pointer; }
        .modal-close { font-size: 1.5rem; border: none; background: none; cursor: pointer; }
        .modal-body { flex-grow: 1; position: relative; display: flex; flex-direction: column; overflow-y: auto;}
        #text-import-textarea { width: 100%; flex-grow: 1; font-family: monospace; font-size: 0.9em; padding: 10px; border: 1px solid #ccc; border-radius: 4px; resize: none; }
        .modal-footer { text-align: right; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; }
        .modal-footer button { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px; }
        .modal-footer .cancel-btn { background-color: #7f8c8d; color: white; }
        .modal-footer .ok-btn { background-color: #3498db; color: white; }
        .drop-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(44, 62, 80, 0.7); color: white; display: none; justify-content: center; align-items: center; font-size: 2em; text-align: center; z-index: 10000; pointer-events: none; }
        body.drag-over .drop-overlay { display: flex; }
        
        .mobile-only-tabs { display: none; flex-shrink: 0; }
        
        #help-modal .modal-body { padding: 0 15px; font-size: 0.9em; line-height: 1.6; }
        #help-modal h4 { margin-top: 20px; margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid #e0e0e0; font-size: 1.1em; color: #2c3e50; }
        #help-modal h4:first-of-type { margin-top: 0; }
        #help-modal p, #help-modal ol { margin-bottom: 15px; }
        #help-modal ol, #help-modal ul { padding-left: 25px; }
        #help-modal li { margin-bottom: 8px; }
        #help-modal ul li { margin-bottom: 5px; }
        #help-modal small { color: #555; }

        .legal-notice { font-size: 11px; text-align: center; padding: 10px 0; color: #555; background: #f0f2f5; border-top: 1px solid #ccc; flex-shrink: 0; }
        #lastUpdated { font-size: 12px; margin-bottom: 10px; }
        #legal-toggle { cursor: pointer; font-weight: bold; }
        #legal-details { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; }
        #legal-details p { margin-bottom: 5px; }

        @media (max-width: 768px) {
            .mobile-only-tabs { display: flex; height: var(--tab-height); }
            .mobile-only-tabs .tab-button { flex-grow: 1; text-align: center; }
            .main-container { flex-direction: column; }
            .left-panel, .right-panel { width: 100%; border-right: none; flex: 1; min-height: 0; }
            .left-panel.hidden-on-mobile, .right-panel.hidden-on-mobile { display: none; }
            .right-panel .tab-bar { display: none; } 
            
            .compact-controls { grid-template-columns: 1fr 1fr; }
            .control-group.pole-height-group { grid-column: 1 / -1; }
            .control-group.mobile-hidden { display: none; }
            .mobile-hidden-col { display: none; }
            
            .header h1 { font-size: 1.2em; }
            .header .header-buttons button { padding: 6px 8px; font-size: 0.8em; }

            .modal-mobile-hidden { display: none !important; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸŒGNSS Viewer</h1>
        <div class="header-buttons">
            <button id="projectLoadBtnHeader" title="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è¾¼">èª­è¾¼</button>
            <button id="projectSaveBtnHeader" title="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜">ä¿å­˜</button>
            <button id="helpBtn" title="ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰">?</button>
        </div>
    </div>
    
    <div class="tab-bar mobile-only-tabs">
        <button id="tab-data-mobile" class="tab-button active">ğŸ“Š ãƒ‡ãƒ¼ã‚¿</button>
        <button id="tab-map-mobile" class="tab-button">ğŸ—ºï¸ åœ°å›³</button>
        <button id="tab-plot-mobile" class="tab-button">ğŸ“ˆ XYãƒ—ãƒ­ãƒƒãƒˆ</button>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <div class="info-panel">
                 <h3>ğŸ“Š æ“ä½œãƒ‘ãƒãƒ«</h3>
                <div class="compact-controls">
                    <div class="control-group">
                        <label>GPXãƒ•ã‚¡ã‚¤ãƒ«</label>
                        <button onclick="document.getElementById('fileInput').click()">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                        <input type="file" id="fileInput" accept=".gpx" multiple style="display: none;">
                    </div>
                    <div class="control-group mobile-hidden">
                        <label>CSV/TXTãƒ•ã‚¡ã‚¤ãƒ«</label>
                        <button onclick="document.getElementById('csvInput').click()">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                        <input type="file" id="csvInput" accept=".csv,.txt" multiple style="display: none;">
                    </div>
                    <div class="control-group mobile-hidden">
                        <label>ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</label>
                        <button id="textImportBtn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                    </div>
                    <div class="control-group">
                        <label>åº§æ¨™ç³»</label>
                        <select id="coordSystem"></select>
                    </div>
                    <div class="control-group pole-height-group">
                        <label>ãƒãƒ¼ãƒ«é«˜è£œæ­£</label>
                        <select id="poleHeight"><option value="0">è£œæ­£ãªã—</option><option value="2.246">ã‚·ãƒ³ãƒ¯ä¼¸ç¸®ãƒãƒ¼ãƒ«(2.246m)</option><option value="2.186">GNSSã‚«ãƒ¼ãƒœãƒ³ãƒãƒ¼ãƒ«(2.186m)</option><option value="1.961">ä¸€è„š(1.961m)</option></select>
                    </div>
                    <div class="control-group mobile-hidden"><label>CSV</label><button id="downloadCsvBtn" style="visibility: hidden;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button></div>
                    <div class="control-group mobile-hidden"><label>DXF</label><button id="downloadDxfBtn" style="visibility: hidden;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button></div>
                </div>
                <input type="file" id="projectInput" accept=".gsv" style="display: none;">
                <div id="file-list-panel-container" style="display: none; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;"><h4 style="font-size: 0.9em; color: #555;">èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«</h4><div id="file-list-panel"></div></div>
            </div>
            <div id="tableContainer"><div class="loading" style="text-align:center; padding-top: 50px;">GPX/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div></div>
        </div>
        <div class="right-panel hidden-on-mobile">
            <div class="tab-bar">
                <button id="tab-map" class="tab-button active">ğŸ—ºï¸ åœ°å›³</button>
                <button id="tab-plot" class="tab-button">ğŸ“ˆ XYãƒ—ãƒ­ãƒƒãƒˆ</button>
            </div>
            <div class="tab-content">
                <div id="pane-map" class="tab-pane active"><div id="map"></div></div>
                <div id="pane-plot" class="tab-pane">
                    <div id="plot-container-wrapper">
                        <div id="plot-controls">
                            <label><input type="checkbox" id="aspectRatioToggle"> ã‚¹ã‚±ãƒ¼ãƒ« 1:1</label>
                            <div id="section-controls-group">
                                <select id="section-mode-select" title="æ–­é¢ç·šã®ä½œæˆæ–¹æ³•ã‚’é¸æŠ">
                                    <option value="2-point">ä»»æ„ã®2ç‚¹</option>
                                    <option value="vertical">é‰›ç›´</option>
                                    <option value="horizontal">æ°´å¹³</option>
                                </select>
                                <label>æ–­é¢å¹…(m): <input type="number" id="section-width-input" value="5.0" step="0.1" style="width: 60px;"></label>
                                <button id="section-line-btn">æ–­é¢ç·šä½œæˆ</button>
                                <button id="create-section-profile-btn" disabled>æ–­é¢å›³ä½œæˆ</button>
                            </div>
                            <span id="section-status" style="display:none; color:#555; flex-grow: 1;"></span>
                            <label style="margin-left: auto;"><input type="checkbox" id="toggleLineOnPlot" checked> æ¥ç¶šãƒ©ã‚¤ãƒ³</label>
                        </div>
                        <div id="plot-canvas-container"><canvas id="xyPlot"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="section-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>æ–­é¢å›³</h3>
                <div class="button-group">
                    <div id="section-type-switch-container" style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; padding: 2px 8px; border: 1px solid #ccc; border-radius: 4px;">
                        <label style="cursor: pointer;"><input type="radio" name="sectionType" value="projected" checked> æŠ•å½±æ–­é¢</label>
                        <label style="cursor: pointer; margin-left: 5px;"><input type="radio" name="sectionType" value="connected"> æ¸¬ç‚¹é€£çµæ–­é¢</label>
                    </div>
                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 0.9em;">
                        <input type="checkbox" id="sectionAspectRatioToggle" style="margin-right: 5px;">ã‚¹ã‚±ãƒ¼ãƒ« 1:1
                    </label>
                    <button id="downloadSectionCsvBtn" class="modal-mobile-hidden">CSV</button>
                    <div id="dxf-export-options" class="modal-mobile-hidden" style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; padding: 2px 8px; border: 1px solid #ccc; border-radius: 4px;">
                        <label style="cursor: pointer;" title="æ–­é¢å›³ã®ã¿ã‚’DXFãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã—ã¾ã™ã€‚"><input type="radio" name="dxfExportType" value="section_only" checked> æ–­é¢å›³ã®ã¿</label>
                        <label style="cursor: pointer; margin-left: 5px;" title="ç¾åœ¨ã®å¹³é¢å›³ã¨æ–­é¢å›³ã‚’1ã¤ã®DXFãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã—ã¾ã™ã€‚"><input type="radio" name="dxfExportType" value="both"> å¹³é¢å›³ã‚‚</label>
                    </div>
                    <button id="downloadSectionDxfBtn" class="modal-mobile-hidden">DXF</button>
                    <button class="modal-close">&times;</button>
                </div>
            </div>
            <div class="modal-body"><canvas id="sectionPlot"></canvas></div>
        </div>
    </div>
    <div class="drop-overlay"><p>ã“ã“ã«GPX/CSV/ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‰ãƒ­ãƒƒãƒ—</p></div>

    <div id="coord-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; height: auto;">
            <div class="modal-header"><h3>åº§æ¨™ç³»ã®ç¢ºèª</h3></div>
            <div class="modal-body" style="padding: 20px;">
                <p>XYåº§æ¨™ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚<br>å¤‰æ›ã«ä½¿ç”¨ã™ã‚‹åº§æ¨™ç³»ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
                <div class="control-group" style="margin-top: 15px;">
                    <label for="modal-coord-system">åº§æ¨™ç³»:</label>
                    <select id="modal-coord-system" style="padding: 8px;"></select>
                </div>
            </div>
            <div class="modal-footer">
                <button id="coord-modal-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="coord-modal-ok" class="ok-btn">æ±ºå®š</button>
            </div>
        </div>
    </div>

    <div id="text-import-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; height: 500px;">
            <div class="modal-header">
                <h3>ãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p style="font-size: 0.9em; margin-bottom: 10px; flex-shrink: 0;">
                    Excelãªã©ã‹ã‚‰æ¸¬ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚(ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š/ã‚¿ãƒ–åŒºåˆ‡ã‚Šã«å¯¾å¿œ)<br>
                    æƒ³å®šã•ã‚Œã‚‹åˆ—: <b>æ¸¬ç‚¹å, (ç·¯åº¦, çµŒåº¦ | Xåº§æ¨™, Yåº§æ¨™), æ¨™é«˜(ã‚¢ãƒ³ãƒ†ãƒŠé«˜)</b>
                </p>
                <textarea id="text-import-textarea" placeholder="ä¾‹:&#10;P1, 35.123, 139.456, 50.1&#10;P2, 1234.5, 5678.9, 33.3 (X, Y)&#10;..."></textarea>
            </div>
            <div class="modal-footer">
                <button id="text-import-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="text-import-ok" class="ok-btn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            </div>
        </div>
    </div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <h4>ã¯ã˜ã‚ã«</h4>
                <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€GNSSæ¸¬é‡ãªã©ã§å–å¾—ã—ãŸæ¸¬é‡ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§å¯è¦–åŒ–ã—ã€ç°¡å˜ãªè§£æã‚„æ–­é¢å›³ä½œæˆã‚’è¡Œã†ãŸã‚ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
                
                <h4>åŸºæœ¬çš„ãªä½¿ã„æ–¹ (3ã‚¹ãƒ†ãƒƒãƒ—)</h4>
                <ol>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</strong><br>
                        æ“ä½œãƒ‘ãƒãƒ«ã®ãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ç”»é¢ã¸ã®ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
                        <ul>
                            <li><b>GPXãƒ•ã‚¡ã‚¤ãƒ«</b>: æ¨™æº–çš„ãªGPXãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¦ã‚§ã‚¤ãƒã‚¤ãƒ³ãƒˆ(wpt)ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚</li>
                            <li><b>CSV/TXTãƒ•ã‚¡ã‚¤ãƒ«</b>: ã‚«ãƒ³ãƒã¾ãŸã¯ã‚¿ãƒ–åŒºåˆ‡ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                            <li><b>ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</b>: Excelãªã©ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥è²¼ã‚Šä»˜ã‘ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                            <li><b>CSV/TXTã®æ›¸å¼</b>: `æ¸¬ç‚¹å, Xåº§æ¨™(ã¾ãŸã¯ç·¯åº¦), Yåº§æ¨™(ã¾ãŸã¯çµŒåº¦), ã‚¢ãƒ³ãƒ†ãƒŠé«˜` ã®é †ã§ãƒ‡ãƒ¼ã‚¿ã‚’ç”¨æ„ã—ã¦ãã ã•ã„ã€‚XYåº§æ¨™ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã‚‹ã¨ã€åº§æ¨™ç³»ã‚’é¸æŠã™ã‚‹ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªã¨æ“ä½œ</strong><br>
                        ãƒ‡ãƒ¼ã‚¿ã¯å·¦ã®ã€Œãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒãƒ«ã€ã¨å³ã®ã€Œåœ°å›³ã€ã€ŒXYãƒ—ãƒ­ãƒƒãƒˆã€ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
                        <ul>
                            <li><b>ãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒãƒ«</b>: ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®è¡¨ç¤º/éè¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆã‚„å‰Šé™¤ãŒã§ãã¾ã™ã€‚</li>
                            <li><b>ãƒ†ãƒ¼ãƒ–ãƒ«</b>: æ¸¬ç‚¹ã®ä¸€è¦§ã§ã™ã€‚è¡Œã®ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆã€æ¸¬ç‚¹åã‚„ã‚¢ãƒ³ãƒ†ãƒŠé«˜ã®ã‚»ãƒ«ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨å€¤ã‚’ç›´æ¥ç·¨é›†ã§ãã¾ã™ã€‚</li>
                            <li><b>åœ°å›³</b>: åœ°ç†é™¢åœ°å›³ä¸Šã«æ¸¬ç‚¹ã®ä½ç½®ãŒãƒ—ãƒ­ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨è©³ç´°æƒ…å ±ã‚’ç¢ºèªã§ãã¾ã™ã€‚</li>
                            <li><b>XYãƒ—ãƒ­ãƒƒãƒˆ</b>: å¹³é¢ç›´è§’åº§æ¨™ç³»ã§ã®ä½ç½®é–¢ä¿‚ã‚’ç¢ºèªã§ãã¾ã™ã€‚ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ï¼ˆç§»å‹•ï¼‰ãŒã§ãã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</strong><br>
                        æ“ä½œãƒ‘ãƒãƒ«ã®ã€ŒCSVã€ã€ŒDXFã€ãƒœã‚¿ãƒ³ã‹ã‚‰ã€è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å…¨æ¸¬ç‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)
                    </li>
                </ol>

                <h4>å¿œç”¨æ©Ÿèƒ½: æ–­é¢å›³ã®ä½œæˆ</h4>
                <ol>
                    <li>XYãƒ—ãƒ­ãƒƒãƒˆã‚¿ãƒ–ã®<b>ã€Œæ–­é¢ç·šä½œæˆã€</b>ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã€ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚</li>
                    <li>
                        <b>æ–­é¢ç·šã®å®šç¾©</b>:
                        <ul>
                            <li><b>ä»»æ„ã®2ç‚¹</b>: ãƒ—ãƒ­ãƒƒãƒˆä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµã¶ç·šã‚’ä½œæˆã—ã¾ã™ã€‚</li>
                            <li><b>é‰›ç›´/æ°´å¹³</b>: ãƒ—ãƒ­ãƒƒãƒˆä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ãã®ä½ç½®ã‚’é€šã‚‹å‚ç›´ç·šã¾ãŸã¯æ°´å¹³ç·šã‚’ä½œæˆã—ã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li><b>æ¸¬ç‚¹ã®é¸æŠ</b>: æ–­é¢ç·šãŒå®šç¾©ã•ã‚Œã‚‹ã¨ã€è¨­å®šã—ãŸã€Œæ–­é¢å¹…ã€ã«å«ã¾ã‚Œã‚‹æ¸¬ç‚¹ãŒè‡ªå‹•çš„ã«é¸æŠã•ã‚Œã¾ã™ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ä¸Šã§ç´«è‰²ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰ã€‚ãƒ—ãƒ­ãƒƒãƒˆä¸Šã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã€æ‰‹å‹•ã§æ¸¬ç‚¹ã‚’è¿½åŠ ãƒ»å‰Šé™¤ã§ãã¾ã™ã€‚</li>
                    <li><b>æ–­é¢å›³ã®ä½œæˆ</b>: æ¸¬ç‚¹ãŒ2ã¤ä»¥ä¸Šé¸æŠã•ã‚ŒãŸçŠ¶æ…‹ã§<b>ã€Œæ–­é¢å›³ä½œæˆã€</b>ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€æ–­é¢å›³ãŒãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                     <li><b>æ–­é¢å›³ã®ç¨®é¡</b>: ã€ŒæŠ•å½±æ–­é¢ã€ã¨ã€Œæ¸¬ç‚¹é€£çµæ–­é¢ã€ã‚’åˆ‡ã‚Šæ›¿ãˆã¦è¡¨ç¤ºã§ãã¾ã™ã€‚</li>
                    <li><b>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</b>: æ–­é¢å›³ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‹ã‚‰ã€æ–­é¢ãƒ‡ãƒ¼ã‚¿ã‚’CSVã¾ãŸã¯DXFå½¢å¼ã§ä¿å­˜ã§ãã¾ã™ã€‚<br>DXFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã§ã¯ã€ã€Œæ–­é¢å›³ã®ã¿ã€ã¾ãŸã¯ã€Œç¾åœ¨ã®å¹³é¢å›³ã¨æ–­é¢å›³ã®ä¸¡æ–¹ã€ã‚’é¸æŠã—ã¦å‡ºåŠ›ã§ãã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                </ol>
                
                <h4>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ©Ÿèƒ½</h4>
                <!-- ã€ä¿®æ­£ã€‘ CSV/TXTãŒä¿å­˜ã§ããªã„æ—¨ã®æ³¨é‡ˆã‚’å‰Šé™¤ -->
                <p>ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã‚ã‚‹<b>ã€Œä¿å­˜ã€</b>ãƒœã‚¿ãƒ³ã§ç¾åœ¨ã®ä½œæ¥­çŠ¶æ…‹ã‚’ `.gsv` ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ã€‚ã“ã‚Œã«ã¯èª­ã¿è¾¼ã‚“ã GPXã€CSVã€TXTã€ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãƒ‡ãƒ¼ã‚¿ã€ç·¨é›†å†…å®¹ã€è¡¨ç¤ºè¨­å®šãªã©ãŒã™ã¹ã¦å«ã¾ã‚Œã¾ã™ã€‚å¾Œã§<b>ã€Œèª­è¾¼ã€</b>ãƒœã‚¿ãƒ³ã‹ã‚‰ä½œæ¥­ã‚’å†é–‹ã§ãã¾ã™ã€‚</p>
            </div>
        </div>
    </div>

    <footer class="legal-notice">
      <div id="lastUpdated"></div>
      <div id="legal-toggle">å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)</div>
      <div id="legal-details">
        <p class="copyright" style="font-weight: bold;">Copyright &copy; 2025 (æ ª)åœ°åœç·åˆã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ All Rights Reserved.</p>
        <p class="developer" style="font-size: 11px;">Developed by: Naoya.Onozato</p>
        <p>æœ¬ã‚µãƒ¼ãƒ“ã‚¹ã®åˆ©ç”¨ã«ã‚ˆã£ã¦ç”Ÿã˜ãŸã„ã‹ãªã‚‹æå®³ã«ã¤ã„ã¦ã‚‚ã€ä½œæˆè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
        <p>æœ¬ã‚µãƒ¼ãƒ“ã‚¹ã¯ä»¥ä¸‹ã®ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŠã‚ˆã³å…¬çš„æ©Ÿé–¢ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™:<br>- åœ°å›³ãƒ‡ãƒ¼ã‚¿: Â© å›½åœŸåœ°ç†é™¢<br>- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª: Leaflet, Chart.js, SortableJS, proj4js</p>
      </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <script>
        // --- (JavaScript) ---
        let map, polylineLayer, sortableInstance, chartInstance, sectionChartInstance, mapSectionLine;
        let loadedFiles = {}, activePoints = [], currentSectionData = {}, lastSectionCoords = null, lastDefinedSectionLinePoints = null;
        let isSectionMode = false, isSectionLineDefined = false, sectionLineStart = null;
        let pointsInLastSectionIds = [];
        let isDrawingSectionLine = false;
        let tempCsvContent = null;
        let tempCsvFileName = null;
        let textImportCounter = 1;
        
        const coordinateSystems = [
          {num:1, lat0:33, lon0:129.5, epsg:6669}, {num:2, lat0:33, lon0:131, epsg:6670},
          {num:3, lat0:36, lon0:132.1666667, epsg:6671}, {num:4, lat0:33, lon0:133.5, epsg:6672},
          {num:5, lat0:36, lon0:134.3333333, epsg:6673}, {num:6, lat0:36, lon0:136, epsg:6674},
          {num:7, lat0:36, lon0:137.1666667, epsg:6675}, {num:8, lat0:36, lon0:138.5, epsg:6676},
          {num:9, lat0:36, lon0:139.8333333, epsg:6677}, {num:10, lat0:40, lon0:140.8333333, epsg:6678},
          {num:11, lat0:44, lon0:140.25, epsg:6679}, {num:12, lat0:44, lon0:142.25, epsg:6680},
          {num:13, lat0:44, lon0:144.25, epsg:6681}, {num:14, lat0:26, lon0:142, epsg:6682},
          {num:15, lat0:26, lon0:127.5, epsg:6683}, {num:16, lat0:26, lon0:124, epsg:6684},
          {num:17, lat0:26, lon0:131, epsg:6685}, {num:18, lat0:20, lon0:136, epsg:6686},
          {num:19, lat0:26, lon0:154, epsg:6687}
        ];
        
function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"' && (i === 0 || line[i-1] !== '\\')) { // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸå¼•ç”¨ç¬¦ã¯ç„¡è¦–
                    if (inQuotes && line[i+1] === '"') { // "" ã¯ä¸€ã¤ã® " ã¨ã—ã¦æ‰±ã†
                        current += '"';
                        i++; // æ¬¡ã® " ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if ((char === ',' || char === '\t') && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, '')); // å‰å¾Œã®å¼•ç”¨ç¬¦ã‚’å‰Šé™¤
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim().replace(/^"|"$/g, ''));
            return result;
        }


        function latLonToXY(lat, lon, systemId) { const system = coordinateSystems.find(s => s.num == systemId); if (!system) throw new Error(`åº§æ¨™ç³» ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`); const [y, x] = proj4('EPSG:4326', `EPSG:${system.epsg}`, [lon, lat]); return { x, y }; }
        function xyToLatLon(x, y, systemId) { const system = coordinateSystems.find(s => s.num == systemId); if (!system) throw new Error(`åº§æ¨™ç³» ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`); const [lon, lat] = proj4(`EPSG:${system.epsg}`, 'EPSG:4326', [y, x]); return { lat, lon }; }
        function initMap() { const gsiStd = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', { attribution: 'Â© GSI' }); map = L.map('map', { layers: [gsiStd] }).setView([36.2, 139.0], 5); L.control.layers({ "åœ°ç†é™¢åœ°å›³": gsiStd, "å†™çœŸ": L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/ort/{z}/{x}/{y}.jpg', { attribution: 'Â© GSI' }) }).addTo(map); L.control.scale({ imperial: false }).addTo(map); polylineLayer = L.layerGroup().addTo(map); }
        function parseGPX(xmlText, fileName) { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlText, 'text/xml'); const wpts = xmlDoc.getElementsByTagName('wpt'); const points = []; for (let i = 0; i < wpts.length; i++) { const wpt = wpts[i]; const getTagText = (p, t) => p.getElementsByTagName(t)[0]?.textContent || null; const d = { id: `${fileName}-${i}`, name: getTagText(wpt, 'name') || `P${points.length + 1}`, lat: parseFloat(wpt.getAttribute('lat')), lon: parseFloat(wpt.getAttribute('lon')), antennaHeight: parseFloat(getTagText(wpt, 'ele') || 0), time: getTagText(wpt, 'time') || '', cmtText: getTagText(wpt, 'cmt') || '', pointGeoidHeight: parseFloat(getTagText(wpt, 'geoidheight') || 0), ellipsoidHeight: null, eleDiff: null, fileName: fileName, modifiedFields: {} }; if (d.cmtText) { const m = d.cmtText.match(/ellipsoidHeight=([\d\.-]+)/); if (m) d.ellipsoidHeight = parseFloat(m[1]); } if (d.ellipsoidHeight !== null && d.pointGeoidHeight !== null) { d.eleDiff = d.antennaHeight - (d.ellipsoidHeight - d.pointGeoidHeight); } points.push(d); } return points; }
        
        function processCsvPoints(csvText, fileName, coordSystemId) {
            const lines = csvText.trim().split(/\r?\n/);
            const headerLineTest = lines[0].toLowerCase();
            const hasHeader = headerLineTest.includes('æ¸¬ç‚¹å') || headerLineTest.includes('name') || headerLineTest.includes('point');
            const dataLines = hasHeader ? lines.slice(1) : lines;
            const points = [];

            for (let i = 0; i < dataLines.length; i++) {
                const values = parseCSVLine(dataLines[i]);
                if (values.length < 3 || values.some(v => v === '')) continue;

                const name = values[0];
                const val1 = parseFloat(values[1]);
                const val2 = parseFloat(values[2]);
                const antennaHeight = values.length > 3 ? parseFloat(values[values.length - 1]) : 0;
                
                if (!name || isNaN(val1) || isNaN(val2) || isNaN(antennaHeight)) continue;
                
                let lat, lon;
                
                if (Math.abs(val1) <= 90 && Math.abs(val2) <= 180) {
                    lat = val1;
                    lon = val2;
                } else {
                    if (!coordSystemId) { throw new Error("XYåº§æ¨™ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸãŒã€æœ‰åŠ¹ãªåº§æ¨™ç³»ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); }
                    const easting = val1;
                    const northing = val2;
                    const latLon = xyToLatLon(easting, northing, coordSystemId);
                    lat = latLon.lat;
                    lon = latLon.lon;
                }
                
                if (isNaN(lat) || isNaN(lon)) { console.warn(`è¡Œ ${i+1} ã®ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã‹ã€åº§æ¨™ç³»ã®è¨­å®šãŒé–“é•ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™: ${dataLines[i]}`); continue; }
                
                points.push({ id: `${fileName}-${i}`, name: name, lat: lat, lon: lon, antennaHeight: antennaHeight, time: '', cmtText: `(CSV Import)`, pointGeoidHeight: 0, ellipsoidHeight: null, eleDiff: null, fileName: fileName, modifiedFields: {} });
            }
            return points;
        }

        function showCoordSystemModal(csvContent, fileName) {
            tempCsvContent = csvContent; tempCsvFileName = fileName;
            const modal = document.getElementById('coord-modal');
            const mainSelect = document.getElementById('coordSystem');
            const modalSelect = document.getElementById('modal-coord-system');
            modalSelect.innerHTML = mainSelect.innerHTML; modalSelect.value = mainSelect.value;
            modal.style.display = 'flex';
        }

function parseCSV(csvText, fileName) {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) throw new Error("ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚");

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // ãƒ˜ãƒƒãƒ€ãƒ¼è¡ŒãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’å…ˆã«åˆ¤å®š
    const headerLineTest = lines[0].toLowerCase();
    const hasHeader = headerLineTest.includes('æ¸¬ç‚¹å') || headerLineTest.includes('name') || headerLineTest.includes('point');

    // ãƒ˜ãƒƒãƒ€ãƒ¼ãŒã‚ã‚Œã°2è¡Œç›®ã€ãªã‘ã‚Œã°1è¡Œç›®ã‚’ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã¨ã™ã‚‹
    const lineToCheck = hasHeader ? lines[1] : lines[0];

    // ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®è¡ŒãŒãªã„å ´åˆï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã—ã‹ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ãªã©ï¼‰ã¯ã‚¨ãƒ©ãƒ¼
    if (!lineToCheck) {
        throw new Error("ãƒ‡ãƒ¼ã‚¿è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
    }
    
    const valuesToCheck = parseCSVLine(lineToCheck);
    if (valuesToCheck.length < 3) throw new Error("ãƒ‡ãƒ¼ã‚¿ã¯å°‘ãªãã¨ã‚‚3åˆ—ï¼ˆæ¸¬ç‚¹å, X/ç·¯åº¦, Y/çµŒåº¦ï¼‰å¿…è¦ã§ã™ã€‚");
    
    const val1 = parseFloat(valuesToCheck[1]);
    const val2 = parseFloat(valuesToCheck[2]);
    
    // val1ã‚„val2ãŒæ•°å€¤ã§ãªã„å ´åˆ(NaN)ã‚‚è€ƒæ…®ã—ã€isLatLonåˆ¤å®šã‚’è¡Œã†
    const isLatLon = !isNaN(val1) && !isNaN(val2) && Math.abs(val1) <= 90 && Math.abs(val2) <= 180;
    // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²
    
    if (isLatLon) {
        const coordSystemId = document.getElementById('coordSystem').value;
        return processCsvPoints(csvText, fileName, coordSystemId);
    } else {
        showCoordSystemModal(csvText, fileName);
        return null;
    }
}

        function processFiles(files) {
            const colors = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6'];
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                const fileType = file.name.toLowerCase().endsWith('.gpx') ? 'gpx' : (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt') ? 'csv' : null);
                if (!fileType) return;
                reader.onload = (e) => {
                    try {
                        const content = e.target.result; let points = [];
                        if (fileType === 'gpx') {
                            points = parseGPX(content, file.name);
                            if(points.length === 0) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã«æ¸¬ç‚¹(<wpt>)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`); return; }
                        } else {
                            points = parseCSV(content, file.name);
                            if (points === null) return;
                            if(points.length === 0) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); return; }
                        }
                        loadedFiles[file.name] = { points, visible: true, color: colors[Object.keys(loadedFiles).length % colors.length], gpxContent: fileType === 'gpx' ? content : null };
                        updateFileListUI(); updateUI();
                    } catch (err) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«è§£æã‚¨ãƒ©ãƒ¼ (${file.name}): ${err.message}`); }
                };
                reader.readAsText(file);
            });
        }

        function updateUI() { activePoints = []; for (const f in loadedFiles) { if (loadedFiles[f].visible) activePoints.push(...loadedFiles[f].points); } rerenderUI(); }
        
        function rerenderUI(highlightPointId = null) {
            const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value);
            const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole }));
            displayTable(processedPoints, highlightPointId); addMarkersAndLine(processedPoints); displayXYPlot(processedPoints, highlightPointId);
            const hasPoints = activePoints.length > 0;
            document.getElementById('downloadCsvBtn').style.visibility = hasPoints ? 'visible' : 'hidden'; document.getElementById('downloadDxfBtn').style.visibility = hasPoints ? 'visible' : 'hidden';
            if (Object.keys(loadedFiles).length === 0) document.getElementById('tableContainer').innerHTML = `<div class="loading" style="text-align:center; padding-top: 50px;">GPX/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>`;
        }
        
        function displayTable(points, highlightPointId) {
            let tableHTML = `<table><thead><tr><th><span title="ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ">&#x2195;</span></th><th class="mobile-hidden-col">ãƒ•ã‚¡ã‚¤ãƒ«å</th><th title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†">æ¸¬ç‚¹å</th><th class="mobile-hidden-col">æ¸¬å®šæ—¥æ™‚</th><th>ç·¯åº¦</th><th>çµŒåº¦</th><th>X (m)</th><th>Y (m)</th><th title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†">ã‚¢ãƒ³ãƒ†ãƒŠé«˜</th><th>è£œæ­£å¾Œæ¨™é«˜</th></tr></thead><tbody>`;
            if (points.length === 0) { tableHTML = `<div class="loading" style="text-align:center; padding-top: 50px;">è¡¨ç¤ºã™ã‚‹æ¸¬ç‚¹ãŒã‚ã‚Šã¾ã›ã‚“</div>`; } else { 
                points.forEach(p => {
                    const highlightClass = p.id === highlightPointId ? 'highlighted' : ''; const nameModifiedClass = p.modifiedFields?.name ? 'modified-cell' : ''; const antennaHeightModifiedClass = p.modifiedFields?.antennaHeight ? 'modified-cell' : '';
                    const inSectionClass = pointsInLastSectionIds.includes(p.id) ? 'in-section' : '';
                    tableHTML += `<tr data-id="${p.id}" class="${highlightClass} ${inSectionClass}">
                        <td class="drag-handle">&#x2195;</td><td class="mobile-hidden-col">${p.fileName}</td>
                        <td class="editable-cell ${nameModifiedClass}" data-field="name"><strong>${p.name}</strong></td>
                        <td class="mobile-hidden-col">${p.time ? new Date(p.time).toLocaleString('ja-JP', { hour12: false }).replace(/\//g, '-') : 'N/A'}</td>
                        <td>${p.lat.toFixed(9)}</td><td>${p.lon.toFixed(9)}</td><td>${p.x.toFixed(3)}</td><td>${p.y.toFixed(3)}</td>
                        <td class="editable-cell ${antennaHeightModifiedClass}" data-field="antennaHeight"><strong>${p.antennaHeight.toFixed(3)}</strong></td>
                        <td>${p.correctedEle.toFixed(3)}</td></tr>`;
                });
                tableHTML += `</tbody></table>`; 
            }
            document.getElementById('tableContainer').innerHTML = tableHTML;
            const tbody = document.querySelector("#tableContainer tbody");
            if (tbody) { if (sortableInstance) sortableInstance.destroy(); sortableInstance = Sortable.create(tbody, { handle: '.drag-handle', animation: 150, onEnd: (evt) => { const item = activePoints.splice(evt.oldIndex, 1)[0]; activePoints.splice(evt.newIndex, 0, item); rerenderUI(); } }); }
        }

        Chart.register(window.ChartZoom);
        const xyPlotAspectRatioPlugin = { id: 'xyPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('aspectRatioToggle').checked || (chart.isZoomedOrPanned && chart.isZoomedOrPanned())) { return; } const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };
        
        function displayXYPlot(points, highlightPointId) {
            const ctx = document.getElementById('xyPlot');
            if (points.length === 0) { if (chartInstance) { chartInstance.destroy(); chartInstance = null; } return; }
            const datasets = {}, lineDatasets = {};
            points.forEach((p, index) => {
                if (!datasets[p.fileName]) { datasets[p.fileName] = { type: 'scatter', label: p.fileName, data: [], pointRadius: [], pointHoverRadius: 8, backgroundColor: [], borderColor: [], borderWidth: [], originalIndices: [] }; lineDatasets[p.fileName] = { type: 'line', label: p.fileName + '-line', data: [], borderColor: loadedFiles[p.fileName].color, borderWidth: 1, pointRadius: 0, showInLegend: false }; }
                datasets[p.fileName].data.push({ x: p.y, y: p.x });
                if (p.id === highlightPointId) { datasets[p.fileName].pointRadius.push(10); datasets[p.fileName].backgroundColor.push('#ff0000'); datasets[p.fileName].borderColor.push('#000000'); datasets[p.fileName].borderWidth.push(2); } else if (pointsInLastSectionIds.includes(p.id)) { datasets[p.fileName].pointRadius.push(6); datasets[p.fileName].backgroundColor.push('#c79fef'); datasets[p.fileName].borderColor.push('#5d3d7e'); datasets[p.fileName].borderWidth.push(1); } else { datasets[p.fileName].pointRadius.push(5); datasets[p.fileName].backgroundColor.push(loadedFiles[p.fileName].color + 'B3'); datasets[p.fileName].borderColor.push(loadedFiles[p.fileName].color); datasets[p.fileName].borderWidth.push(1); }
                datasets[p.fileName].originalIndices.push(index); lineDatasets[p.fileName].data.push({ x: p.y, y: p.x });
            });
            const finalDatasets = document.getElementById('toggleLineOnPlot').checked ? [...Object.values(datasets), ...Object.values(lineDatasets)] : Object.values(datasets);
            const annotations = {};
            if (isSectionLineDefined && lastDefinedSectionLinePoints) { const line = lastDefinedSectionLinePoints; const p1 = line[0]; const p2 = line[line.length - 1]; annotations.sectionLine = { type: 'line', xMin: p1.x, yMin: p1.y, xMax: p2.x, yMax: p2.y, borderColor: 'red', borderWidth: 2 }; }
            if (chartInstance) { chartInstance.data.datasets = finalDatasets; chartInstance.options.plugins.annotation.annotations = annotations; chartInstance.update();
            } else {
                chartInstance = new Chart(ctx, {
                    data: { datasets: finalDatasets }, plugins: [xyPlotAspectRatioPlugin],
                    options: { animation: false, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Yåº§æ¨™ (m)' } }, y: { title: { display: true, text: 'Xåº§æ¨™ (m)' } } }, plugins: { annotation: { annotations }, tooltip: { filter: (item) => item.dataset.type === 'scatter', callbacks: { label: ctx => `${activePoints[Object.values(datasets)[ctx.datasetIndex].originalIndices[ctx.dataIndex]].name}: (Y=${ctx.parsed.x.toFixed(3)}, X=${ctx.parsed.y.toFixed(3)})` } }, zoom: { zoom: { wheel: { enabled: true }, mode: 'xy' }, pan: { enabled: true, mode: 'xy' } } },
                        onClick: (evt) => { if (chartInstance.isZoomedOrPanned() && evt.native.detail === 2) { chartInstance.resetZoom(); return; } handlePlotClick(evt); },
                    }
                });
            }
        }
        
        function addMarkersAndLine(points) { polylineLayer.clearLayers(); if (mapSectionLine) polylineLayer.addLayer(mapSectionLine); const allBounds = []; const pointsByFile = {}; points.forEach(p => { const marker = L.marker([p.lat, p.lon]); marker.bindPopup(`<strong>${p.name}</strong><br>æ¨™é«˜: ${p.correctedEle.toFixed(3)}m`); polylineLayer.addLayer(marker); p.marker = marker; allBounds.push([p.lat, p.lon]); if (!pointsByFile[p.fileName]) pointsByFile[p.fileName] = []; pointsByFile[p.fileName].push(p); }); for (const f in pointsByFile) { if (pointsByFile[f].length > 1) { const latlngs = pointsByFile[f].map(p => [p.lat, p.lon]); polylineLayer.addLayer(L.polyline(latlngs, { color: loadedFiles[f].color, weight: 2 })); } } if (allBounds.length > 0 && !isSectionMode) map.fitBounds(allBounds, { padding: [50, 50] }); }
        window.focusOnPoint = (event, pointId) => { if (!pointId || (event && event.target.tagName.toLowerCase() === 'input')) return; rerenderUI(pointId); const point = activePoints.find(p => p.id === pointId); if (point?.marker) { point.marker.openPopup(); map.setView(point.marker.getLatLng(), 18); } const row = document.querySelector(`tr[data-id="${pointId}"]`); if(row) row.scrollIntoView({ behavior: 'auto', block: 'center' }); };
        function handleTableCellEdit(e) { const cell = e.target.closest('.editable-cell'); if (!cell || cell.querySelector('input')) return; const originalText = cell.querySelector('strong')?.textContent || cell.textContent; const field = cell.dataset.field; const pointId = cell.parentElement.dataset.id; cell.innerHTML = `<input type="text" value="${originalText.trim()}" />`; const input = cell.querySelector('input'); input.focus(); input.select(); const save = () => { const point = activePoints.find(p => p.id === pointId); const masterPoint = loadedFiles[point.fileName].points.find(p => p.id === pointId); const newValue = input.value; let changed = false; if (field === 'antennaHeight') { const num = parseFloat(newValue); if (!isNaN(num) && masterPoint.antennaHeight.toFixed(3) !== num.toFixed(3)) { point.antennaHeight = masterPoint.antennaHeight = num; changed = true; } } else { if (masterPoint.name !== newValue) { point.name = masterPoint.name = newValue; changed = true; } } if (changed) { masterPoint.modifiedFields[field] = true; } rerenderUI(pointId); }; input.addEventListener('blur', save); input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') input.blur(); if (ev.key === 'Escape') { input.removeEventListener('blur', save); rerenderUI(pointId); } }); }
        function updateFileListUI() { const panel = document.getElementById('file-list-panel'); document.getElementById('file-list-panel-container').style.display = Object.keys(loadedFiles).length > 0 ? 'block' : 'none'; panel.innerHTML = ''; for (const f in loadedFiles) { const item = document.createElement('div'); item.className = 'file-item'; item.innerHTML = `<input type="checkbox" id="check-${f}" ${loadedFiles[f].visible?'checked':''}> <label for="check-${f}" title="${f}">${f}</label> <button class="delete-btn" title="å‰Šé™¤">&times;</button>`; panel.appendChild(item); item.querySelector('input').addEventListener('change', (e) => { loadedFiles[f].visible = e.target.checked; updateUI(); }); item.querySelector('button').addEventListener('click', () => { delete loadedFiles[f]; updateFileListUI(); updateUI(); }); } }
        
        function toggleSectionLineMode() {
            isSectionMode = !isSectionMode;
            const btn = document.getElementById('section-line-btn');
            const status = document.getElementById('section-status');
            const canvas = document.getElementById('xyPlot');
            const createBtn = document.getElementById('create-section-profile-btn');
            
            btn.classList.toggle('active', isSectionMode);
            sectionLineStart = null; isSectionLineDefined = false; lastDefinedSectionLinePoints = null;
            createBtn.disabled = true; canvas.classList.remove('crosshair', 'editable-section');
            
            if (isSectionMode) {
                const aspectRatioToggle = document.getElementById('aspectRatioToggle');
                if (aspectRatioToggle.checked) { aspectRatioToggle.checked = false; aspectRatioToggle.dispatchEvent(new Event('change')); }
                status.style.display = 'inline';
                canvas.classList.add('crosshair');
                const mode = document.getElementById('section-mode-select').value;
                switch(mode) {
                    case '2-point': status.textContent = 'ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ–­é¢ç·šã‚’è¨­å®š'; break;
                    case 'vertical': status.textContent = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦é‰›ç›´ç·šã®ä½ç½®ã‚’æ±ºå®š'; break;
                    case 'horizontal': status.textContent = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ°´å¹³ç·šã®ä½ç½®ã‚’æ±ºå®š'; break;
                }
            } else {
                status.style.display = 'none';
                pointsInLastSectionIds = [];
            }
            if (!isSectionMode) { rerenderUI(); }
        }
        
        function getChartCoordsFromClick(e) { if (!chartInstance) return null; return { x: chartInstance.scales.x.getValueForPixel(e.x), y: chartInstance.scales.y.getValueForPixel(e.y) }; }
        function getChartCoordsFromCanvasEvent(e) { if (!chartInstance) return null; let clientX, clientY; const eventType = e.type; if (eventType.startsWith('touch')) { e.preventDefault(); const touch = (eventType === 'touchend' || eventType === 'touchcancel') ? e.changedTouches[0] : e.touches[0]; if (!touch) return null; clientX = touch.clientX; clientY = touch.clientY; } else { clientX = e.clientX; clientY = e.clientY; } const rect = e.target.getBoundingClientRect(); const offsetX = clientX - rect.left; const offsetY = clientY - rect.top; return { x: chartInstance.scales.x.getValueForPixel(offsetX), y: chartInstance.scales.y.getValueForPixel(offsetY) }; }
        function handlePlotDrawStart(e) { if (!isSectionMode || isSectionLineDefined || document.getElementById('section-mode-select').value !== '2-point') return; isDrawingSectionLine = true; sectionLineStart = getChartCoordsFromCanvasEvent(e); }
        function handlePlotDrawMove(e) { if (!sectionLineStart || !isDrawingSectionLine) return; const current = getChartCoordsFromCanvasEvent(e); if (current) { const annotations = chartInstance.options.plugins.annotation.annotations; if (!annotations.tempLine) { annotations.tempLine = { type: 'line', xMin: sectionLineStart.x, yMin: sectionLineStart.y, xMax: current.x, yMax: current.y, borderColor: 'rgba(255,0,0,0.5)', borderWidth: 2, drawTime: 'afterDraw' }; } else { annotations.tempLine.xMax = current.x; annotations.tempLine.yMax = current.y; } chartInstance.update('none'); } }
        function handlePlotDrawEnd(e) { if (!sectionLineStart || !isDrawingSectionLine) return; isDrawingSectionLine = false; const end = getChartCoordsFromCanvasEvent(e); delete chartInstance.options.plugins.annotation.annotations.tempLine; if (end) { if (Math.abs(sectionLineStart.x - end.x) > 1e-6 || Math.abs(sectionLineStart.y - end.y) > 1e-6) { defineSectionLineOnMapAndChart([sectionLineStart, end]); } } sectionLineStart = null; }

        function handlePlotClick(evt) {
            const elems = chartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (isSectionMode) {
                if (isSectionLineDefined) {
                    const scatterElems = elems.filter(e => chartInstance.data.datasets[e.datasetIndex].type === 'scatter');
                    if (scatterElems.length > 0) {
                        const elem = scatterElems[0]; const ds = chartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; const pointId = activePoints[ptIdx].id;
                        const indexInSelection = pointsInLastSectionIds.indexOf(pointId);
                        if (indexInSelection > -1) { pointsInLastSectionIds.splice(indexInSelection, 1); } else { pointsInLastSectionIds.push(pointId); }
                        document.getElementById('create-section-profile-btn').disabled = pointsInLastSectionIds.length < 2;
                        updateSelectionHighlights();
                    }
                } else {
                    const mode = document.getElementById('section-mode-select').value; const point = getChartCoordsFromClick(evt); if (!point) return; const { x: scaleX, y: scaleY } = chartInstance.scales; let linePoints = null;
                    switch(mode) { case 'vertical': linePoints = [{x: point.x, y: scaleY.min}, {x: point.x, y: scaleY.max}]; break; case 'horizontal': linePoints = [{x: scaleX.min, y: point.y}, {x: scaleX.max, y: point.y}]; break; }
                    if(linePoints) { defineSectionLineOnMapAndChart(linePoints); }
                }
            } else { const scatterElems = elems.filter(e => chartInstance.data.datasets[e.datasetIndex].type === 'scatter'); if (scatterElems.length > 0) { const elem = scatterElems[0]; const ds = chartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; focusOnPoint(null, activePoints[ptIdx].id); } }
        }
        
        function updateSelectionHighlights() {
            document.querySelectorAll('#tableContainer tr[data-id]').forEach(row => { row.classList.toggle('in-section', pointsInLastSectionIds.includes(row.dataset.id)); });
            if (!chartInstance) return; const highlightPointId = document.querySelector('tr.highlighted')?.dataset.id;
            chartInstance.data.datasets.forEach(dataset => { if (dataset.type !== 'scatter') return; dataset.originalIndices.forEach((originalIndex, dataIndex) => { const point = activePoints[originalIndex]; if (!point) return; if (point.id === highlightPointId) { dataset.pointRadius[dataIndex] = 10; dataset.backgroundColor[dataIndex] = '#ff0000'; dataset.borderColor[dataIndex] = '#000000'; dataset.borderWidth[dataIndex] = 2; } else if (pointsInLastSectionIds.includes(point.id)) { dataset.pointRadius[dataIndex] = 6; dataset.backgroundColor[dataIndex] = '#c79fef'; dataset.borderColor[dataIndex] = '#5d3d7e'; dataset.borderWidth[dataIndex] = 1; } else { dataset.pointRadius[dataIndex] = 5; dataset.backgroundColor[dataIndex] = loadedFiles[point.fileName].color + 'B3'; dataset.borderColor[dataIndex] = loadedFiles[point.fileName].color; dataset.borderWidth[dataIndex] = 1; } }); });
            chartInstance.update('none');
        }

        function defineSectionLineOnMapAndChart(linePoints) {
            isSectionLineDefined = true; lastDefinedSectionLinePoints = linePoints; document.getElementById('xyPlot').classList.remove('crosshair'); document.getElementById('xyPlot').classList.add('editable-section');
            const systemId = document.getElementById('coordSystem').value;
            const latLonLine = linePoints.map(p => xyToLatLon(p.y, p.x, systemId));
            lastSectionCoords = { path: latLonLine, pathXY: linePoints }; if (mapSectionLine) map.removeLayer(mapSectionLine); const mapLineCoords = latLonLine.map(p => [p.lat, p.lon]); mapSectionLine = L.polyline(mapLineCoords, { color: 'red', weight: 3, dashArray: '5, 5' }).addTo(polylineLayer);
            document.getElementById('section-status').textContent = 'ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ–­é¢ã«å«ã‚ã‚‹æ¸¬ç‚¹ã‚’ç·¨é›†ã§ãã¾ã™';
            const width = parseFloat(document.getElementById('section-width-input').value); if(isNaN(width) || width <= 0) return;
            pointsInLastSectionIds = [];
            activePoints.forEach(p => {
                const p_xy = latLonToXY(p.lat, p.lon, systemId); const pt = { x: p_xy.y, y: p_xy.x }; const closestInfo = findClosestPointOnPolyline(pt, lastDefinedSectionLinePoints);
                if (closestInfo.distance <= width / 2) { pointsInLastSectionIds.push(p.id); }
            });
            document.getElementById('create-section-profile-btn').disabled = pointsInLastSectionIds.length < 2;
            rerenderUI();
        }

        function updateSectionPlot(sectionType) {
            if (pointsInLastSectionIds.length < 2) { currentSectionData = []; }
            else if (sectionType === 'projected' && !lastDefinedSectionLinePoints) { currentSectionData = []; }
            else {
                const systemId = document.getElementById('coordSystem').value;
                const pole = parseFloat(document.getElementById('poleHeight').value);
                const sectionPoints = activePoints.filter(p => pointsInLastSectionIds.includes(p.id));

                if (sectionType === 'projected') {
                    currentSectionData = sectionPoints.map(p => {
                        const p_xy = latLonToXY(p.lat, p.lon, systemId);
                        const pt = { x: p_xy.y, y: p_xy.x }; const closestInfo = findClosestPointOnPolyline(pt, lastDefinedSectionLinePoints);
                        return { x: closestInfo.distAlong, y: p.antennaHeight - pole, name: p.name, antennaHeight: p.antennaHeight, originalX: p_xy.x, originalY: p_xy.y };
                    }).sort((a, b) => a.x - b.x);
                } else { // 'connected'
                    let cumulativeDistance = 0;
                    currentSectionData = sectionPoints.map((p, i) => {
                        const p_xy = latLonToXY(p.lat, p.lon, systemId);
                        if (i > 0) {
                            const prev_p = sectionPoints[i-1];
                            const prev_p_xy = latLonToXY(prev_p.lat, prev_p.lon, systemId);
                            const dx = p_xy.x - prev_p_xy.x; const dy = p_xy.y - prev_p_xy.y;
                            cumulativeDistance += Math.sqrt(dx*dx + dy*dy);
                        }
                        return { x: cumulativeDistance, y: p.antennaHeight - pole, name: p.name, antennaHeight: p.antennaHeight, originalX: p_xy.x, originalY: p_xy.y };
                    });
                }
            }
            if (sectionChartInstance) {
                sectionChartInstance.data.datasets[0].data = currentSectionData;
                sectionChartInstance.update();
            }
        }
        
        function generateAndShowSectionProfile() {
            if (pointsInLastSectionIds.length < 2) { alert("æ–­é¢ã«å«ã‚ã‚‹æ¸¬ç‚¹ãŒ2ã¤ä»¥ä¸Šé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }
            if (!lastDefinedSectionLinePoints) { alert("æ–­é¢ç·šãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }
            
            document.querySelector('#section-type-switch-container input[value="projected"]').checked = true;
            displaySectionProfileModal();
            updateSectionPlot('projected');
        }

        function findClosestPointOnPolyline(point, polyline) { let bestResult = { distance: Infinity, distAlong: 0 }; let accumulatedLength = 0; for (let i = 0; i < polyline.length - 1; i++) { const p1 = polyline[i]; const p2 = polyline[i+1]; const segLenSq = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2); let closest; let t = 0; if (segLenSq === 0) { closest = p1; } else { t = ((point.x - p1.x) * (p2.x - p1.x) + (point.y - p1.y) * (p2.y - p1.y)) / segLenSq; t = Math.max(0, Math.min(1, t)); closest = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) }; } const distSq = Math.pow(point.x - closest.x, 2) + Math.pow(point.y - closest.y, 2); if (distSq < bestResult.distance * bestResult.distance) { bestResult.distance = Math.sqrt(distSq); bestResult.distAlong = accumulatedLength + t * Math.sqrt(segLenSq); } accumulatedLength += Math.sqrt(segLenSq); } return bestResult; }
        const sectionPlotAspectRatioPlugin = { id: 'sectionPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('sectionAspectRatioToggle').checked) { return; } const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };

        function displaySectionProfileModal() { 
            const modal = document.getElementById('section-modal'); modal.style.display = 'flex'; const ctx = document.getElementById('sectionPlot'); if (sectionChartInstance) sectionChartInstance.destroy();
            sectionChartInstance = new Chart(ctx, { type: 'line', data: { datasets: [{ label: 'æ–­é¢æ¨™é«˜', data: [], borderColor: '#3498db', tension: 0, pointBackgroundColor: '#3498db', showLine: true }] }, plugins: [sectionPlotAspectRatioPlugin], options: { maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'å§‹ç‚¹ã‹ã‚‰ã®è·é›¢ (m)' } }, y: { title: { display: true, text: 'è£œæ­£å¾Œæ¨™é«˜ (m)' } } }, plugins: { tooltip: { callbacks: { label: ctx => `${ctx.raw.name}: (è·é›¢ ${ctx.parsed.x.toFixed(3)}m, æ¨™é«˜ ${ctx.parsed.y.toFixed(3)}m)` } } } } }); 
            setTimeout(() => sectionChartInstance.resize(), 100); 
        }
        
        function toDxfUnicode(text) { let result = ''; for (let i = 0; i < text.length; i++) { const char = text[i]; const charCode = char.charCodeAt(0); if (charCode > 127) { result += `\\U+${charCode.toString(16).padStart(4, '0')}`; } else { result += char; } } return result; }
        
        function generateDxfHeaderAndTables(isCombined = false) {
            let dxf = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nTABLES\n`;
            dxf += `0\nTABLE\n2\nSTYLE\n70\n1\n0\nSTYLE\n2\nMSP-GOTHIC\n70\n0\n40\n0.0\n41\n1.0\n50\n0.0\n71\n0\n42\n0.25\n3\nMS Pã‚´ã‚·ãƒƒã‚¯\n4\n\n0\nENDTAB\n`;
            dxf += `0\nTABLE\n2\nLAYER\n70\n10\n`;
            
            const planLayers = [
                {name: 'PLAN_POINTS', color: 1}, {name: 'PLAN_TEXT', color: 2}, {name: 'PLAN_LINES', color: 3}, 
                {name: 'PLAN_SECTION_LINE', color: 1, linetype: 'DASHDOT'}, {name: 'PLAN_GRID_LINES', color: 8, linetype: 'DOTTED'}, {name: 'PLAN_GRID_TEXT', color: 8}
            ];
            const sectionLayers = [
                {name: 'SECTION_PROFILE', color: 4}, {name: 'SECTION_POINTS', color: 5}, {name: 'SECTION_TEXT', color: 6},
                {name: 'SECTION_GRID_LINES', color: 8, linetype: 'DOTTED'}, {name: 'SECTION_GRID_TEXT', color: 8}
            ];
            
            const layers = isCombined ? [...planLayers, ...sectionLayers] : (activePoints.length > 0 ? planLayers : sectionLayers);
            
            const uniqueLayers = layers.filter((layer, index, self) => index === self.findIndex((l) => l.name === layer.name));
            uniqueLayers.forEach(l => {
                dxf += `0\nLAYER\n2\n${l.name}\n70\n0\n62\n${l.color}\n6\n${l.linetype || 'CONTINUOUS'}\n`;
            });

            dxf += `0\nENDTAB\n0\nENDSEC\n`;
            return dxf;
        }

        function generateDxfEntities(points, gridInterval) {
            let dxf = '';
            if (gridInterval > 0 && points.length > 0) {
                const minX = Math.min(...points.map(p=>p.y)), maxX = Math.max(...points.map(p=>p.y));
                const minY = Math.min(...points.map(p=>p.x)), maxY = Math.max(...points.map(p=>p.x));
                const startX = Math.floor(minX / gridInterval) * gridInterval, endX = Math.ceil(maxX / gridInterval) * gridInterval;
                const startY = Math.floor(minY / gridInterval) * gridInterval, endY = Math.ceil(maxY / gridInterval) * gridInterval;
                for (let x = startX; x <= endX; x += gridInterval) {
                    dxf += `0\nLINE\n8\nPLAN_GRID_LINES\n10\n${x}\n20\n${minY}\n30\n0\n11\n${x}\n21\n${maxY}\n31\n0\n`;
                    dxf += `0\nTEXT\n8\nPLAN_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${x}\n20\n${minY}\n30\n0\n40\n${gridInterval/10}\n1\n${x.toFixed(1)}\n`;
                }
                for (let y = startY; y <= endY; y += gridInterval) {
                    dxf += `0\nLINE\n8\nPLAN_GRID_LINES\n10\n${minX}\n20\n${y}\n30\n0\n11\n${maxX}\n21\n${y}\n31\n0\n`;
                    dxf += `0\nTEXT\n8\nPLAN_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${minX}\n20\n${y}\n30\n0\n40\n${gridInterval/10}\n1\n${y.toFixed(1)}\n`;
                }
            }
            points.forEach(p => {
                dxf += `0\nPOINT\n8\nPLAN_POINTS\n10\n${p.y.toFixed(4)}\n20\n${p.x.toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n`;
                dxf += `0\nTEXT\n8\nPLAN_TEXT\n7\nMSP-GOTHIC\n10\n${(p.y + 0.1).toFixed(4)}\n20\n${(p.x + 0.1).toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n40\n0.25\n1\n${toDxfUnicode(p.name)}\n`;
            });
            const pointsByFile = {};
            points.forEach(p => { if (!pointsByFile[p.fileName]) pointsByFile[p.fileName] = []; pointsByFile[p.fileName].push(p); });
            for(const fileName in pointsByFile) {
                if(pointsByFile[fileName].length < 2) continue;
                dxf += `0\nPOLYLINE\n8\nPLAN_LINES\n66\n1\n70\n0\n`;
                pointsByFile[fileName].forEach(p => { dxf += `0\nVERTEX\n8\nPLAN_LINES\n10\n${p.y.toFixed(4)}\n20\n${p.x.toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n`; });
                dxf += `0\nSEQEND\n`;
            }
            if(lastSectionCoords && lastSectionCoords.pathXY.length > 1) {
                dxf += `0\nPOLYLINE\n8\nPLAN_SECTION_LINE\n66\n1\n70\n0\n`;
                lastSectionCoords.pathXY.forEach(p => { dxf += `0\nVERTEX\n8\nPLAN_SECTION_LINE\n10\n${p.x}\n20\n${p.y}\n30\n0\n`; });
                dxf += `0\nSEQEND\n`;
            }
            return dxf;
        }
        
        function generateSectionDxfEntities(data, gridInterval, offsetX = 0, offsetY = 0) {
            let dxf = '';
            if (gridInterval > 0 && data.length > 0) {
                const minX = 0, maxX = Math.max(...data.map(p=>p.x));
                const minY = Math.min(...data.map(p=>p.y)), maxY = Math.max(...data.map(p=>p.y));
                const startX = 0, endX = Math.ceil(maxX / gridInterval) * gridInterval;
                const startY = Math.floor(minY / gridInterval) * gridInterval, endY = Math.ceil(maxY / gridInterval) * gridInterval;
                for (let x = startX; x <= endX; x += gridInterval) {
                    dxf += `0\nLINE\n8\nSECTION_GRID_LINES\n10\n${x+offsetX}\n20\n${minY+offsetY}\n30\n0\n11\n${x+offsetX}\n21\n${maxY+offsetY}\n31\n0\n`;
                    dxf += `0\nTEXT\n8\nSECTION_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${x+offsetX}\n20\n${minY+offsetY}\n30\n0\n40\n${gridInterval/10}\n1\n${x.toFixed(1)}\n`;
                }
                for (let y = startY; y <= endY; y += gridInterval) {
                    dxf += `0\nLINE\n8\nSECTION_GRID_LINES\n10\n${minX+offsetX}\n20\n${y+offsetY}\n30\n0\n11\n${maxX+offsetX}\n21\n${y+offsetY}\n31\n0\n`;
                    dxf += `0\nTEXT\n8\nSECTION_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${minX+offsetX}\n20\n${y+offsetY}\n30\n0\n40\n${gridInterval/10}\n1\n${y.toFixed(1)}\n`;
                }
            }
            dxf += `0\nPOLYLINE\n8\nSECTION_PROFILE\n66\n1\n70\n0\n`;
            data.forEach(p => { dxf += `0\nVERTEX\n8\nSECTION_PROFILE\n10\n${(p.x + offsetX).toFixed(4)}\n20\n${(p.y + offsetY).toFixed(4)}\n30\n0\n`; });
            dxf += `0\nSEQEND\n`;
            data.forEach(p => {
                dxf += `0\nPOINT\n8\nSECTION_POINTS\n10\n${(p.x + offsetX).toFixed(4)}\n20\n${(p.y + offsetY).toFixed(4)}\n30\n0\n`;
                dxf += `0\nTEXT\n8\nSECTION_TEXT\n7\nMSP-GOTHIC\n10\n${(p.x + 0.1 + offsetX).toFixed(4)}\n20\n${(p.y + 0.1 + offsetY).toFixed(4)}\n30\n0\n40\n0.25\n1\n${toDxfUnicode(p.name)}\n`;
                const coordText = `(Y=${p.originalY.toFixed(3)},X=${p.originalX.toFixed(3)})`;
                dxf += `0\nTEXT\n8\nSECTION_TEXT\n7\nMSP-GOTHIC\n10\n${(p.x + 0.1 + offsetX).toFixed(4)}\n20\n${(p.y - 0.3 + offsetY).toFixed(4)}\n30\n0\n40\n0.15\n1\n${toDxfUnicode(coordText)}\n`;
            });
            return dxf;
        }

function generateCombinedDxfContent(gridIntervalPlan, gridIntervalSection) {
    const sys = document.getElementById('coordSystem').value;
    const pole = parseFloat(document.getElementById('poleHeight').value);
    const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole }));
    if (processedPoints.length === 0) { alert("å¹³é¢å›³ã«å‡ºåŠ›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return ''; }

    // --- â–¼ ä¸è¦ãªã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ã‚’å‰Šé™¤ â–¼ ---
    /*
    const planMinX = Math.min(...processedPoints.map(p => p.y)); const planMaxX = Math.max(...processedPoints.map(p => p.y));
    const planMinY = Math.min(...processedPoints.map(p => p.x)); const planMaxY = Math.max(...processedPoints.map(p => p.x));
    const planWidth = planMaxX - planMinX; const planHeight = planMaxY - planMinY;

    const sectionMinElev = Math.min(...currentSectionData.map(p => p.y)); const sectionMaxElev = Math.max(...currentSectionData.map(p => p.y));
    const sectionHeight = sectionMaxElev - sectionMinElev;
    
    const margin = Math.max(planWidth, planHeight) * 0.1 || 10;
    const offsetX = planMinX;
    const offsetY = planMinY - margin - sectionHeight;
    */
    // --- â–² ä¸è¦ãªã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ã‚’å‰Šé™¤ â–² ---

    let dxf = generateDxfHeaderAndTables(true);
    dxf += `0\nSECTION\n2\nENTITIES\n`;
    dxf += generateDxfEntities(processedPoints, gridIntervalPlan);
    // --- â–¼ ã‚ªãƒ•ã‚»ãƒƒãƒˆã« 0 ã‚’æŒ‡å®šã™ã‚‹ â–¼ ---
    dxf += generateSectionDxfEntities(currentSectionData, gridIntervalSection, 0, 0); 
    // --- â–² ã‚ªãƒ•ã‚»ãƒƒãƒˆã« 0 ã‚’æŒ‡å®šã™ã‚‹ â–² ---
    dxf += `0\nENDSEC\n0\nEOF\n`;
    return dxf;
}
        
        document.getElementById('downloadCsvBtn').addEventListener('click', () => { if (activePoints.length === 0) return; const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); const coordSysText = document.getElementById('coordSystem').selectedOptions[0].textContent; const poleHeightText = document.getElementById('poleHeight').selectedOptions[0].textContent; let csv = "\uFEFF"; csv += `åº§æ¨™ç³»,${coordSysText}\r\n`; csv += `ãƒãƒ¼ãƒ«é«˜è£œæ­£,${poleHeightText}\r\n\r\n`; csv += "ãƒ•ã‚¡ã‚¤ãƒ«å,æ¸¬ç‚¹å,æ¸¬å®šæ—¥æ™‚,ç·¯åº¦,çµŒåº¦,Xåº§æ¨™(m),Yåº§æ¨™(m),ã‚¢ãƒ³ãƒ†ãƒŠé«˜(m),è£œæ­£å¾Œæ¨™é«˜(m),cmt\r\n"; const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys) , correctedEle: p.antennaHeight - pole })); processedPoints.forEach(p => { const ts = p.time ? new Date(p.time).toLocaleString('ja-JP') : ''; const cmtSanitized = '"' + (p.cmtText || '').replace(/"/g, '""') + '"'; const row = [ p.fileName, p.name, ts, p.lat.toFixed(9), p.lon.toFixed(9), p.x.toFixed(4), p.y.toFixed(4), p.antennaHeight.toFixed(4), p.correctedEle.toFixed(4), cmtSanitized ].join(","); csv += row + "\r\n"; }); if(lastSectionCoords) { csv += "\r\næ–­é¢ç·šæƒ…å ±\r\né …ç›®,ç·¯åº¦,çµŒåº¦,Xåº§æ¨™,Yåº§æ¨™\r\n"; lastSectionCoords.path.forEach((p, i) => { csv += `çµŒç”±ç‚¹${i+1},${p.lat.toFixed(9)},${p.lon.toFixed(9)},${lastSectionCoords.pathXY[i].y.toFixed(4)},${lastSectionCoords.pathXY[i].x.toFixed(4)}\r\n`; }); } const link = document.createElement("a"); link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv); link.download = `survey_data_edited_ç³»${sys}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
        document.getElementById('downloadDxfBtn').addEventListener('click', () => { if (activePoints.length === 0) return; const gridInterval = parseFloat(prompt("ã‚°ãƒªãƒƒãƒ‰ã®é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚(ä¸è¦ãªå ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«)", "10.0")); const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole })); let dxfContent = generateDxfHeaderAndTables() + `0\nSECTION\n2\nENTITIES\n` + generateDxfEntities(processedPoints, gridInterval) + `0\nENDSEC\n0\nEOF\n`; const blob = new Blob([dxfContent], { type: 'application/dxf' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `survey_data_ç³»${sys}.dxf`; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
        document.getElementById('downloadSectionCsvBtn').addEventListener('click', () => { if (currentSectionData.length === 0) return; let csv = "\uFEFF"; csv += "æ¸¬ç‚¹å,å§‹ç‚¹ã‹ã‚‰ã®è·é›¢(m),ã‚¢ãƒ³ãƒ†ãƒŠé«˜(m),è£œæ­£å¾Œæ¨™é«˜(m),Xåº§æ¨™(m),Yåº§æ¨™(m)\r\n"; currentSectionData.forEach(p => { csv += `${p.name},${p.x.toFixed(4)},${p.antennaHeight.toFixed(4)},${p.y.toFixed(4)},${p.originalX.toFixed(4)},${p.originalY.toFixed(4)}\r\n`; }); const link = document.createElement("a"); link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv); link.download = 'section_data.csv'; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
        
        document.getElementById('downloadSectionDxfBtn').addEventListener('click', () => {
            if (currentSectionData.length === 0) return;
            
            const exportType = document.querySelector('input[name="dxfExportType"]:checked').value;
            const gridIntervalSection = parseFloat(prompt("ã€æ–­é¢å›³ã€‘ã‚°ãƒªãƒƒãƒ‰ã®é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚(ä¸è¦ãªå ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«)", "1.0"));
            if (isNaN(gridIntervalSection)) return;

            let dxfContent = '';
            let fileName = 'section_data.dxf';

            if (exportType === 'section_only') {
                dxfContent = generateDxfHeaderAndTables() + `0\nSECTION\n2\nENTITIES\n` + generateSectionDxfEntities(currentSectionData, gridIntervalSection) + `0\nENDSEC\n0\nEOF\n`;
            } else { // 'both'
                const gridIntervalPlan = parseFloat(prompt("ã€å¹³é¢å›³ã€‘ã‚°ãƒªãƒƒãƒ‰ã®é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚(ä¸è¦ãªå ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«)", "10.0"));
                if (isNaN(gridIntervalPlan)) return;
                dxfContent = generateCombinedDxfContent(gridIntervalPlan, gridIntervalSection);
                fileName = 'plan_and_section_data.dxf';
            }

            if (dxfContent) {
                const blob = new Blob([dxfContent], { type: 'application/dxf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        });

        // --- â–¼â–¼â–¼ã€ä¿®æ­£ã€‘ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜ãƒ»èª­è¾¼æ©Ÿèƒ½ã‚’æ”¹å–„ â–¼â–¼â–¼ ---
        function saveProject() {
            if (Object.keys(loadedFiles).length === 0) {
                alert("ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            }
            const projectData = {
                version: "3.1", // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°
                savedAt: new Date().toISOString(),
                loadedFiles: {},
                pointOrder: activePoints.map(p => p.id),
                uiState: {
                    coordSystem: document.getElementById('coordSystem').value,
                    poleHeight: document.getElementById('poleHeight').value,
                    mapView: { center: map.getCenter(), zoom: map.getZoom() },
                    lastSectionCoords: lastSectionCoords,
                    activeTabId: document.querySelector('.tab-button.active').id
                }
            };

            for (const fileName in loadedFiles) {
                const fileData = loadedFiles[fileName];
                const savedFile = {
                    gpxContent: fileData.gpxContent,
                    visible: fileData.visible,
                    color: fileData.color,
                    modifications: {},
                    // ã€è¿½åŠ ã€‘ gpxContentãŒãªã„å ´åˆã€ãƒã‚¤ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥ä¿å­˜
                    pointsData: fileData.gpxContent === null ? fileData.points.map(p => ({
                        id: p.id, name: p.name, lat: p.lat, lon: p.lon, antennaHeight: p.antennaHeight, time: p.time, cmtText: p.cmtText,
                        pointGeoidHeight: p.pointGeoidHeight, ellipsoidHeight: p.ellipsoidHeight, eleDiff: p.eleDiff
                    })) : null
                };

                fileData.points.forEach(p => {
                    if (Object.keys(p.modifiedFields).length > 0) {
                        savedFile.modifications[p.id] = {};
                        if (p.modifiedFields.name) savedFile.modifications[p.id].name = p.name;
                        if (p.modifiedFields.antennaHeight) savedFile.modifications[p.id].antennaHeight = p.antennaHeight;
                    }
                });
                projectData.loadedFiles[fileName] = savedFile;
            }

            const jsonString = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `gnss-viewer-project.gsv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function loadProject(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const projectData = JSON.parse(e.target.result);
                    if (!projectData.version || !projectData.loadedFiles) {
                        throw new Error("ç„¡åŠ¹ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚");
                    }
                    loadedFiles = {};
                    activePoints = [];
                    lastSectionCoords = null;
                    if (chartInstance) {
                        chartInstance.destroy();
                        chartInstance = null;
                    }

                    for (const fileName in projectData.loadedFiles) {
                        const fileData = projectData.loadedFiles[fileName];
                        let points = [];

                        // ã€ä¿®æ­£ã€‘ gpxContent ã¾ãŸã¯ pointsData ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
                        if (fileData.gpxContent) {
                            points = parseGPX(fileData.gpxContent, fileName);
                        } else if (fileData.pointsData) {
                            points = fileData.pointsData.map(p => ({ ...p, fileName: fileName, modifiedFields: {} }));
                        } else {
                            console.warn(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã® ${fileName} ã«ã¯è¡¨ç¤ºã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                            continue;
                        }

                        if (fileData.modifications) {
                            points.forEach(p => {
                                if (fileData.modifications[p.id]) {
                                    const mod = fileData.modifications[p.id];
                                    if (mod.name) {
                                        p.name = mod.name;
                                        p.modifiedFields.name = true;
                                    }
                                    if (mod.antennaHeight !== undefined) {
                                        p.antennaHeight = mod.antennaHeight;
                                        p.modifiedFields.antennaHeight = true;
                                    }
                                }
                            });
                        }
                        loadedFiles[fileName] = { points: points, visible: fileData.visible, color: fileData.color, gpxContent: fileData.gpxContent };
                    }

                    const ui = projectData.uiState;
                    document.getElementById('coordSystem').value = ui.coordSystem;
                    document.getElementById('poleHeight').value = ui.poleHeight;
                    map.setView(ui.mapView.center, ui.mapView.zoom);
                    lastSectionCoords = ui.lastSectionCoords;
                    
                    updateFileListUI();
                    // ã€ä¿®æ­£ã€‘ rerenderUIã§ã¯ãªãupdateUIã‚’å‘¼ã³å‡ºã—ã¦ã€activePointsã‚’æ­£ã—ãå†æ§‹ç¯‰ã™ã‚‹
                    updateUI();

                } catch (err) {
                    alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${err.message}`);
                } finally {
                    document.getElementById('projectInput').value = '';
                }
            };
            reader.readAsText(file);
        }
        // --- â–²â–²â–²ã€ä¿®æ­£ã€‘ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜ãƒ»èª­è¾¼æ©Ÿèƒ½ã‚’æ”¹å–„ â–²â–²â–² ---

        function initialize() {
            coordinateSystems.forEach(sys => { const projDef = `+proj=tmerc +lat_0=${sys.lat0} +lon_0=${sys.lon0} +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs`; proj4.defs(`EPSG:${sys.epsg}`, projDef); });
            for (let i = 1; i <= 19; i++) { const opt = document.createElement('option'); opt.value = i; opt.textContent = `ç¬¬${i}ç³»`; if (i === 9) opt.selected = true; document.getElementById('coordSystem').appendChild(opt); }
            initMap();
            document.getElementById('fileInput').addEventListener('change', (e) => processFiles(e.target.files));
            document.getElementById('csvInput').addEventListener('change', (e) => processFiles(e.target.files));
            document.getElementById('coordSystem').addEventListener('change', () => rerenderUI());
            document.getElementById('poleHeight').addEventListener('change', () => rerenderUI());
            document.getElementById('toggleLineOnPlot').addEventListener('change', () => rerenderUI());
            document.getElementById('aspectRatioToggle').addEventListener('change', () => { if (chartInstance) chartInstance.update(); });
            const tableContainer = document.getElementById('tableContainer');
            tableContainer.addEventListener('click', (e) => { const targetRow = e.target.closest('tr'); if (!targetRow) return; if (targetRow.classList.contains('highlighted') && e.target.closest('.editable-cell')) return; focusOnPoint(e, targetRow.dataset.id); });
            tableContainer.addEventListener('dblclick', handleTableCellEdit);
            const mobileTabs = document.querySelector('.mobile-only-tabs'); const desktopTabs = document.querySelector('.right-panel .tab-bar'); const leftPanel = document.querySelector('.left-panel'); const rightPanel = document.querySelector('.right-panel');
            mobileTabs.addEventListener('click', (e) => { if (!e.target.classList.contains('tab-button')) return; mobileTabs.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); const targetId = e.target.id; if (targetId === 'tab-data-mobile') { leftPanel.classList.remove('hidden-on-mobile'); rightPanel.classList.add('hidden-on-mobile'); } else { leftPanel.classList.add('hidden-on-mobile'); rightPanel.classList.remove('hidden-on-mobile'); if (targetId === 'tab-map-mobile') { document.getElementById('tab-map').click(); } else if (targetId === 'tab-plot-mobile') { document.getElementById('tab-plot').click(); } } });
            desktopTabs.addEventListener('click', (e) => { if (!e.target.classList.contains('tab-button')) return; desktopTabs.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active')); document.querySelectorAll('#pane-map, #pane-plot').forEach(pane => pane.classList.remove('active')); e.target.classList.add('active'); const paneId = e.target.id.replace('tab-', 'pane-'); document.getElementById(paneId).classList.add('active'); if (paneId === 'pane-map') { setTimeout(() => map.invalidateSize(), 10); } else if (paneId === 'pane-plot' && chartInstance) { setTimeout(() => chartInstance.resize(), 10); } });
            const body = document.body; body.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('drag-over'); }); body.addEventListener('dragleave', () => body.classList.remove('drag-over')); body.addEventListener('drop', (e) => { e.preventDefault(); body.classList.remove('drag-over'); processFiles(e.dataTransfer.files); });
            document.getElementById('section-line-btn').addEventListener('click', toggleSectionLineMode);
            document.getElementById('create-section-profile-btn').addEventListener('click', generateAndShowSectionProfile);
            document.getElementById('sectionAspectRatioToggle').addEventListener('change', () => { if (sectionChartInstance) sectionChartInstance.update(); });
            const plotCanvas = document.getElementById('xyPlot');
            plotCanvas.addEventListener('mousedown', handlePlotDrawStart); plotCanvas.addEventListener('mousemove', handlePlotDrawMove); plotCanvas.addEventListener('mouseup', handlePlotDrawEnd);
            plotCanvas.addEventListener('touchstart', handlePlotDrawStart, { passive: false }); plotCanvas.addEventListener('touchmove', handlePlotDrawMove, { passive: false }); plotCanvas.addEventListener('touchend', handlePlotDrawEnd);
            const sectionModal = document.getElementById('section-modal');
            sectionModal.addEventListener('click', (e) => { if (e.target === sectionModal || e.target.classList.contains('modal-close')) sectionModal.style.display = 'none'; });
            window.addEventListener('resize', () => { setTimeout(() => { if(map) map.invalidateSize(); if(chartInstance) chartInstance.resize(); if(sectionChartInstance) sectionChartInstance.resize(); }, 100); });
            
            document.getElementById('projectSaveBtnHeader').addEventListener('click', saveProject);
            document.getElementById('projectLoadBtnHeader').addEventListener('click', () => document.getElementById('projectInput').click());
            
            document.getElementById('projectInput').addEventListener('change', (e) => loadProject(e.target.files[0]));
            document.getElementById('legal-toggle').addEventListener('click', () => { const details = document.getElementById('legal-details'); const toggle = document.getElementById('legal-toggle'); const isHidden = details.style.display === 'none'; details.style.display = isHidden ? 'block' : 'none'; toggle.textContent = isHidden ? 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§éè¡¨ç¤º)' : 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)'; });
            const coordModal = document.getElementById('coord-modal');
            document.getElementById('coord-modal-ok').addEventListener('click', () => {
                const selectedSystemId = document.getElementById('modal-coord-system').value;
                try {
                    const points = processCsvPoints(tempCsvContent, tempCsvFileName, selectedSystemId);
                    if(points.length === 0) { alert(`ãƒ‡ãƒ¼ã‚¿ã€Œ${tempCsvFileName}ã€ã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); } else {
                        const colors = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6'];
                        loadedFiles[tempCsvFileName] = { points, visible: true, color: colors[Object.keys(loadedFiles).length % colors.length], gpxContent: null };
                        updateFileListUI(); updateUI();
                    }
                } catch (err) { alert(`ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼ (${tempCsvFileName}): ${err.message}`); } finally { coordModal.style.display = 'none'; tempCsvContent = null; tempCsvFileName = null; }
            });
            document.getElementById('coord-modal-cancel').addEventListener('click', () => { coordModal.style.display = 'none'; tempCsvContent = null; tempCsvFileName = null; });
            const textImportModal = document.getElementById('text-import-modal');
            document.getElementById('textImportBtn').addEventListener('click', () => { textImportModal.style.display = 'flex'; document.getElementById('text-import-textarea').value = ''; });
            textImportModal.querySelector('.modal-close').addEventListener('click', () => textImportModal.style.display = 'none');
            document.getElementById('text-import-cancel').addEventListener('click', () => textImportModal.style.display = 'none');
            document.getElementById('text-import-ok').addEventListener('click', () => {
                const textContent = document.getElementById('text-import-textarea').value;
                if (textContent.trim() === '') { alert('ãƒ†ã‚­ã‚¹ãƒˆãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); return; }
                const fileName = `Pasted_Data_${textImportCounter++}`;
                try {
                    const points = parseCSV(textContent, fileName);
                    if (points === null) { /* åº§æ¨™ç³»ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒè¡¨ç¤ºã•ã‚Œã‚‹ */ }
                    else if(points.length === 0) { alert(`è²¼ã‚Šä»˜ã‘ã‚‰ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); }
                    else {
                        const colors = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6'];
                        loadedFiles[fileName] = { points, visible: true, color: colors[Object.keys(loadedFiles).length % colors.length], gpxContent: null };
                        updateFileListUI(); updateUI();
                    }
                } catch (err) { alert(`ãƒ†ã‚­ã‚¹ãƒˆè§£æã‚¨ãƒ©ãƒ¼: ${err.message}`); }
                textImportModal.style.display = 'none';
            });
            document.querySelectorAll('#section-type-switch-container input[name="sectionType"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateSectionPlot(e.target.value));
            });

            const today = new Date();
            document.getElementById('lastUpdated').textContent = `æœ€çµ‚æ›´æ–°æ—¥: ${today.getFullYear()}å¹´${today.getMonth() + 1}æœˆ${today.getDate()}æ—¥`;

            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('help-modal');
            helpBtn.addEventListener('click', () => { helpModal.style.display = 'flex'; });
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal || e.target.classList.contains('modal-close')) {
                    helpModal.style.display = 'none';
                }
            });
        }
        
        initialize();
    </script>
</body>
</html>