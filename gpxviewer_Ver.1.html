<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GNSS Viewer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        :root { --header-height: 60px; --tab-height: 40px; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; background: #f0f2f5; }
        .header { background: #2c3e50; color: white; padding: 0 20px; height: var(--header-height); display: flex; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex-shrink: 0; z-index: 20; }
        .header h1 { flex-grow: 1; font-size: 1.5em; }
        .header .header-buttons { margin-left: auto; display: flex; align-items: center; gap: 10px; }
        .header .header-buttons button { background: #3498db; color: white; border: none; border-radius: 5px; padding: 8px 12px; font-size: 0.9em; cursor: pointer; white-space: nowrap; }
        .header .header-buttons button:hover { background: #2980b9; }
        .header .header-buttons button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
        .header #undoBtn { background: #f39c12; }
        .header #undoBtn:hover:not(:disabled) { background: #e67e22; }
        .header #helpBtn { background: #95a5a6; border-radius: 50%; width: 32px; height: 32px; font-size: 1.4em; font-weight: bold; padding: 0; }
        .header #helpBtn:hover { background: #7f8c8d; }

        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; height: calc(100% - var(--header-height) - 40px); }
        .left-panel { width: 60%; display: flex; flex-direction: column; background: #ecf0f1; border-right: 1px solid #95a5a6; box-shadow: 2px 0 4px rgba(0,0,0,0.1); }
        .right-panel { width: 40%; display: flex; flex-direction: column; }
        
        .tab-bar { flex-shrink: 0; display: flex; background-color: #ecf0f1; border-bottom: 2px solid #bdc3c7; flex-wrap: wrap;}
        .tab-button { padding: 0 15px; height: var(--tab-height); border: none; background: #ecf0f1; cursor: pointer; font-size: 0.9em; color: #7f8c8d; border-bottom: 3px solid transparent; }
       
 .tab-button.active { 
            background: #fff; 
            color: #2c3e50; 
            font-weight: bold; 
            border: 2px solid #bdc3c7;
            border-bottom: 3px solid #3498db;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            position: relative;
            top: 1px;
            padding-bottom: 2px;
        }

        .tab-content { flex-grow: 1; position: relative; background: #fff;}
        .tab-pane { width: 100%; height: 100%; position: absolute; visibility: hidden; opacity: 0; transition: opacity 0.2s; }
        .tab-pane.active { visibility: visible; opacity: 1; }
        #map { width: 100%; height: 100%; }
        .plot-container-wrapper { display: flex; flex-direction: column; height: 100%; }
        .plot-controls { padding: 8px; background: #f8f9fa; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; font-size: 0.85em; }
        .plot-controls label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        .plot-controls select, .plot-controls input[type="number"] { padding: 4px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; }
        .plot-controls button { padding: 4px 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; cursor: pointer; }
        .plot-controls button:disabled { background-color: #e0e0e0; cursor: not-allowed; }
        .plot-controls button.active { background: #3498db; color: white; border-color: #2980b9; }
        #section-controls-group { display: flex; gap: 8px; align-items: center; }
        .plot-canvas-container { flex-grow: 1; position: relative; padding: 10px; }
        #xyPlot.crosshair { cursor: crosshair; }
        #xyPlot.editable-section { cursor: pointer; }

        #plot-context-menu { position: absolute; display: none; background: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); padding: 5px 0; border-radius: 4px; z-index: 1000; font-size: 0.9em;}
        #plot-context-menu button { display: block; width: 100%; padding: 8px 15px; border: none; background: none; text-align: left; cursor: pointer; }
        #plot-context-menu button:hover { background: #f0f0f0; }

        .info-panel { padding: 10px 15px; background: #fff; margin: 10px 10px 0 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); flex-shrink: 0; }
        .compact-controls { display: grid; grid-template-columns: repeat(3, auto) 1fr 2fr repeat(3, auto); gap: 8px; margin-bottom: 10px; align-items: end;}
        .control-group { display: flex; flex-direction: column; }
        .control-group label { font-size: 0.8em; margin-bottom: 2px; color: #555; font-weight: bold; }
        .control-group input, .control-group select, .control-group button { padding: 8px; background: #fff; border-radius: 4px; border: 1px solid #ccc; font-size: 0.9em; width: 100%; }
        .control-group button { background-color: #3498db; color: white; border: none; cursor: pointer; text-align: center;}
        .compact-controls .control-group button { width: auto; white-space: nowrap; padding-left: 12px; padding-right: 12px; }
        .control-group button:hover { background-color: #2980b9; }
        
        #tableContainer { flex-grow: 1; overflow-y: auto; margin: 10px; border: 1px solid #ccc; }
        table { width: 100%; border-collapse: collapse; background: white; font-size: 0.8em; }
        thead { position: sticky; top: 0; background: #34495e; color: white; z-index: 10; }
        th, td { padding: 8px 10px; text-align: left; border: 1px solid #ddd; white-space: nowrap; user-select: text; }
        .drag-handle { cursor: move; user-select: none; width: 20px; text-align: center; }
        .visibility-toggle { cursor: pointer; user-select: none; }
        tbody tr:nth-child(even) { background-color: #f8f9fa; }
        tbody tr.hidden-row { opacity: 0.5; background-color: #e9ecef !important; text-decoration: line-through; }
        tbody tr.highlighted { background-color: #aed6f1 !important; }
        tbody tr.in-section { background-color: #e8dff5 !important; font-weight: bold; }
        tbody tr.sortable-ghost { background: #c8ebfb; }
        td.editable-cell:hover { background-color: #fffacd; cursor: text; }
        td.editable-cell input { width: 100%; border: 1px solid #3498db; outline: none; padding: 6px; box-sizing: border-box; font-size: 1em; }
        td.modified-cell { background-color: #e0f7fa; }
        td.modified-cell > strong::after { content: " âœï¸"; font-size: 0.8em; display: inline-block; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 80%; max-width: 900px; height: 80%; max-height: 600px; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 15px; }
        .modal-header .button-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: flex-end; }
        .modal-header button { padding: 4px 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #fff; cursor: pointer; }
        .modal-close { font-size: 1.5rem; border: none; background: none; cursor: pointer; }
        .modal-body { flex-grow: 1; position: relative; display: flex; flex-direction: column; overflow-y: auto;}
        #text-import-textarea { width: 100%; flex-grow: 1; font-family: monospace; font-size: 0.9em; padding: 10px; border: 1px solid #ccc; border-radius: 4px; resize: none; }
        .modal-footer { text-align: right; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; }
        .modal-footer button { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px; }
        .modal-footer .cancel-btn { background-color: #7f8c8d; color: white; }
        .modal-footer .ok-btn { background-color: #3498db; color: white; }
        .drop-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(44, 62, 80, 0.7); color: white; display: none; justify-content: center; align-items: center; font-size: 2em; text-align: center; z-index: 10000; pointer-events: none; }
        body.drag-over .drop-overlay { display: flex; }
        
        #stats-modal.draggable { position: fixed; display: none; flex-direction: column; width: auto; max-width: 90vw; height: auto; max-height: 70vh; left: 20px; top: 80px; background: white; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1001; border: 1px solid #bdc3c7; }
        #stats-modal .modal-header { cursor: move; padding: 10px 15px; margin-bottom: 0; background-color: #f8f9fa; color: #2c3e50; }
        #stats-modal .modal-body { padding: 0 15px 15px 15px; }
        
        .mobile-only-tabs { display: none; flex-shrink: 0; flex-wrap: wrap; }
        
        #help-modal .modal-body { padding: 0 15px; font-size: 0.9em; line-height: 1.6; }
        #help-modal h4 { margin-top: 20px; margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid #e0e0e0; font-size: 1.1em; color: #2c3e50; }
        #help-modal h4:first-of-type { margin-top: 0; }
        #help-modal p, #help-modal ol { margin-bottom: 15px; }
        #help-modal ol, #help-modal ul { padding-left: 25px; }
        #help-modal li { margin-bottom: 8px; }
        #help-modal ul li { margin-bottom: 5px; }
        #help-modal small { color: #555; }

        .legal-notice { font-size: 11px; text-align: center; padding: 10px 0; color: #555; background: #f0f2f5; border-top: 1px solid #ccc; flex-shrink: 0; }
        #lastUpdated { font-size: 12px; margin-bottom: 10px; }
        #legal-toggle { cursor: pointer; font-weight: bold; }
        #legal-details { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; }
        #legal-details p { margin-bottom: 5px; }
        .color-indicator { display: inline-block; width: 12px; height: 12px; border: 1px solid #ccc; margin-right: 5px; vertical-align: middle; }
        .leaflet-popup-content .action-button { background-color: #3498db; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-size: 12px; margin-top: 5px;}
        .leaflet-popup-content .action-button:hover { background-color: #2980b9; }

        .loading { color: #7f8c8d; }

@media (max-width: 768px) {
            /* â–¼ã“ã“ã‹ã‚‰ä¿®æ­£ */
            .mobile-only-tabs {
                display: flex;
                height: auto;
                overflow-x: auto; /* æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹ã«ã™ã‚‹ */
                flex-wrap: nowrap;  /* æŠ˜ã‚Šè¿”ã—ã‚’ç¦æ­¢ã™ã‚‹ */
                -webkit-overflow-scrolling: touch; /* iOSã§ã®æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
                scrollbar-width: none; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤º (Firefox) */
            }
            .mobile-only-tabs::-webkit-scrollbar {
                display: none; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤º (Chrome, Safari) */
            }
            .mobile-only-tabs .tab-button {
                flex-grow: 0; /* ãƒœã‚¿ãƒ³ãŒä¼¸ã³ãªã„ã‚ˆã†ã«ã™ã‚‹ */
                flex-shrink: 0; /* ãƒœã‚¿ãƒ³ãŒç¸®ã¾ãªã„ã‚ˆã†ã«ã™ã‚‹ */
                text-align: center;
                white-space: nowrap; /* ãƒœã‚¿ãƒ³å†…ã®ãƒ†ã‚­ã‚¹ãƒˆæ”¹è¡Œã‚’é˜²ã */
            }
            /* â–²ã“ã“ã¾ã§ä¿®æ­£ */

            .main-container { flex-direction: column; }
            .left-panel, .right-panel { width: 100%; border-right: none; flex: 1; min-height: 0; }
            .left-panel.hidden-on-mobile, .right-panel.hidden-on-mobile { display: none; }
            .right-panel .tab-bar { display: none; } /* â† ã“ã®è¡Œã¯å¿…ãšæ®‹ã—ã¦ãã ã•ã„ */
            
            .compact-controls { grid-template-columns: 1fr 1fr 1fr; }
            
            .control-group.mobile-hidden { display: none; }
            .mobile-hidden-col { display: none; }
            
            .header h1 { font-size: 1.2em; }
            .header .header-buttons button { padding: 6px 8px; font-size: 0.8em; }

            .modal-mobile-hidden { display: none !important; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸŒGNSS Viewer</h1>
        <div class="header-buttons">
            <button id="undoBtn" title="å…ƒã«æˆ»ã™" disabled>â†©ï¸æˆ»ã™</button>
            <button id="projectLoadBtnHeader" title="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è¾¼">ğŸ“¥èª­è¾¼</button>
            <button id="projectSaveBtnHeader" title="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜">ğŸ’¾ä¿å­˜</button>
            <button id="helpBtn" title="ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰">?</button>
        </div>
    </div>
    
    <div class="tab-bar mobile-only-tabs">
        <button id="tab-data-mobile" class="tab-button active">ğŸ“Š ãƒ‡ãƒ¼ã‚¿</button>
        <button id="tab-map-mobile" class="tab-button">ğŸ—ºï¸ åœ°å›³</button>
        <button id="tab-plot-mobile" class="tab-button">ğŸ“ˆ XY</button>
        <button id="tab-xz-plot-mobile" class="tab-button">ğŸ“‰ XZ</button> <!-- â† è¿½åŠ  -->
        <button id="tab-yz-plot-mobile" class="tab-button">ğŸ“‰ YZ</button> <!-- â† è¿½åŠ  -->
        <button id="tab-3d-plot-mobile" class="tab-button">ğŸŒ 3D</button>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <div class="info-panel">
                <div class="compact-controls">
                    <div class="control-group">
                        <label>GPX</label>
                        <button onclick="document.getElementById('fileInput').click()">ğŸ“‚é–‹ã</button>
                        <input type="file" id="fileInput" accept=".gpx" multiple style="display: none;">
                    </div>
                    <div class="control-group mobile-hidden">
                        <label>CSV/TXT</label>
                        <button onclick="document.getElementById('csvInput').click()">ğŸ§¾é–‹ã</button>
                        <input type="file" id="csvInput" accept=".csv,.txt" multiple style="display: none;">
                    </div>
                    <div class="control-group mobile-hidden">
                        <label>ãƒ†ã‚­ã‚¹ãƒˆ</label>
                        <button id="textImportBtn">ğŸ“å…¥åŠ›</button>
                    </div>
                    <div class="control-group">
                        <label>ğŸ§­åº§æ¨™ç³»</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <select id="coordSystem" style="flex-grow: 0.5;"></select>
                            <a href="https://www.gsi.go.jp/sokuchikijun/jpc.html" target="_blank" rel="noopener noreferrer" title="æ—¥æœ¬ã®æ¸¬åœ°åº§æ¨™ç³»ã«ã¤ã„ã¦ï¼ˆå›½åœŸåœ°ç†é™¢ï¼‰" style="flex-shrink: 0; text-decoration: none; border: 1px solid #ccc; border-radius: 50%; width: 22px; height: 22px; display: inline-flex; justify-content: center; align-items: center; color: #3498db; font-weight: bold; background-color: #fff;">?</a>
                        </div>
                    </div>
                    <div class="control-group pole-height-group">
                        <label for="poleHeight">ğŸ“ãƒãƒ¼ãƒ«é«˜è£œæ­£ (m)</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <select id="poleHeightPreset" style="flex-grow: 8; flex-basis: 0;">
                                <option value="">ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚‰é¸æŠ...</option>
                                <option value="0">è£œæ­£ãªã—</option>
                                <option value="2.186">GNSSã‚«ãƒ¼ãƒœãƒ³ãƒãƒ¼ãƒ«(2.186m)</option>
                                <option value="2.246">ã‚·ãƒ³ãƒ¯ä¼¸ç¸®ãƒãƒ¼ãƒ«(2.246m)</option>
                                <option value="1.961">ä¸€è„š(1.961m)</option>
                            </select>
                            <input type="number" id="poleHeight" value="0" step="0.001" style="flex-grow: 1; flex-basis: 0; min-width: 100px;">    
                        </div>
                    </div>
                    <div class="control-group mobile-hidden">
                        <label>çµ±è¨ˆå‡¦ç†</label>
                        <button id="clusterStatsBtn">ğŸ“Šè¿‘æ¥ç‚¹å‡¦ç†</button>
                    </div>
                    <div class="control-group mobile-hidden"><label>CSV</label><button id="downloadCsvBtn" style="visibility: hidden;">ğŸ’¾ä¿å­˜</button></div>
                    <div class="control-group mobile-hidden"><label>DXF</label><button id="downloadDxfBtn" style="visibility: hidden;">ğŸ“ä¿å­˜</button></div>
                </div>
                <input type="file" id="projectInput" accept=".gsv" style="display: none;">
                <div id="file-list-panel-container" style="display: none; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;"><h4 style="font-size: 0.9em; color: #555;">èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«</h4><div id="file-list-panel"></div></div>
            </div>
            <div id="tableContainer"><div class="loading" style="text-align:center; padding-top: 50px;">GPX/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div></div>
        </div>
        <div class="right-panel hidden-on-mobile">
            <div class="tab-bar">
                <button id="tab-map" class="tab-button active">ğŸ—ºï¸ åœ°å›³</button>
                <button id="tab-plot" class="tab-button">ğŸ“ˆ XYãƒ—ãƒ­ãƒƒãƒˆ</button>
                <button id="tab-xz-plot" class="tab-button">ğŸ“‰ XZãƒ—ãƒ­ãƒƒãƒˆ</button>
                <button id="tab-yz-plot" class="tab-button">ğŸ“‰ YZãƒ—ãƒ­ãƒƒãƒˆ</button>
                <button id="tab-3d-plot" class="tab-button">ğŸŒ 3Dãƒ—ãƒ­ãƒƒãƒˆ</button>
            </div>
            <div class="tab-content">
                <div id="pane-map" class="tab-pane active"><div id="map"></div></div>
                <div id="pane-plot" class="tab-pane">
                    <div class="plot-container-wrapper">
                        <div class="plot-controls">
                            <label><input type="checkbox" id="aspectRatioToggle"> ğŸ“ã‚¹ã‚±ãƒ¼ãƒ« 1:1 1ï¸âƒ£</label>
                            <div id="section-controls-group">
                                <select id="section-mode-select" title="æ–­é¢ç·šã®ä½œæˆæ–¹æ³•ã‚’é¸æŠ">
                                    <option value="2-point">â‘ ä»»æ„ã®2ç‚¹</option>
                                    <option value="vertical">â‘¡é‰›ç›´</option>
                                    <option value="horizontal">â‘¢æ°´å¹³</option>
                                    <option value="coords">â‘£åº§æ¨™æŒ‡å®š</option>
                                </select>
                                <label>2ï¸âƒ£æ–­é¢å¹…(m): <input type="number" id="section-width-input" value="5.0" step="0.1" style="width: 60px;"></label>
                                <button id="section-line-btn">3ï¸âƒ£æ–­é¢ç·šä½œæˆ</button>
                                <button id="create-section-profile-btn" disabled>4ï¸âƒ£æ–­é¢å›³ä½œæˆ</button>
                            </div>
                            <span id="section-status" style="display:none; color:#555; flex-grow: 1;"></span>
                            <label style="margin-left: auto;"><input type="checkbox" id="toggleLineOnPlot" checked> æ¥ç¶šãƒ©ã‚¤ãƒ³</label>
                        </div>
                        <div class="plot-canvas-container">
                            <canvas id="xyPlot"></canvas>
                             <div id="plot-context-menu">
                                <button id="hide-point-from-plot-btn">ã“ã®ç‚¹ã‚’éè¡¨ç¤º</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="pane-xz-plot" class="tab-pane">
                    <div class="plot-container-wrapper">
                        <div class="plot-controls">
                            <label><input type="checkbox" id="xzAspectRatioToggle"> ğŸ“ã‚¹ã‚±ãƒ¼ãƒ« 1:1</label>
                            <label style="margin-left: auto;"><input type="checkbox" id="toggleLineOnXzPlot" checked> æ¥ç¶šãƒ©ã‚¤ãƒ³</label>
                        </div>
                        <div class="plot-canvas-container"><canvas id="xzPlot"></canvas></div>
                    </div>
                </div>
                <div id="pane-yz-plot" class="tab-pane">
                    <div class="plot-container-wrapper">
                        <div class="plot-controls">
                            <label><input type="checkbox" id="yzAspectRatioToggle"> ğŸ“ã‚¹ã‚±ãƒ¼ãƒ« 1:1</label>
                            <label style="margin-left: auto;"><input type="checkbox" id="toggleLineOnYzPlot" checked> æ¥ç¶šãƒ©ã‚¤ãƒ³</label>
                        </div>
                        <div class="plot-canvas-container"><canvas id="yzPlot"></canvas></div>
                    </div>
                </div>
                <div id="pane-3d-plot" class="tab-pane">
                    <div class="plot-container-wrapper">
                        <div class="plot-controls">
                            <label><input type="checkbox" id="plot3dAspectRatioToggle"> ğŸ“ã‚¹ã‚±ãƒ¼ãƒ« 1:1</label>
                        </div>
                        <div class="plot-canvas-container">
                            <div id="plot-3d-container" style="width: 100%; height: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="section-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>æ–­é¢å›³</h3>
                <div class="button-group">
                    <div id="section-type-switch-container" style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; padding: 2px 8px; border: 1px solid #ccc; border-radius: 4px;">
                        <label style="cursor: pointer;"><input type="radio" name="sectionType" value="projected" checked> æŠ•å½±æ–­é¢</label>
                        <label style="cursor: pointer; margin-left: 5px;"><input type="radio" name="sectionType" value="connected"> æ¸¬ç‚¹é€£çµæ–­é¢</label>
                    </div>
                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 0.9em;">
                        <input type="checkbox" id="sectionAspectRatioToggle" style="margin-right: 5px;">ã‚¹ã‚±ãƒ¼ãƒ« 1:1
                    </label>
                    <button id="downloadSectionCsvBtn" class="modal-mobile-hidden">CSV</button>
                    <div id="dxf-export-options" class="modal-mobile-hidden" style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; padding: 2px 8px; border: 1px solid #ccc; border-radius: 4px;">
                        <label style="cursor: pointer;" title="æ–­é¢å›³ã®ã¿ã‚’DXFãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã—ã¾ã™ã€‚"><input type="radio" name="dxfExportType" value="section_only" checked> æ–­é¢å›³ã®ã¿</label>
                        <label style="cursor: pointer; margin-left: 5px;" title="ç¾åœ¨ã®å¹³é¢å›³ã¨æ–­é¢å›³ã‚’1ã¤ã®DXFãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã—ã¾ã™ã€‚"><input type="radio" name="dxfExportType" value="both"> å¹³é¢å›³ã‚‚</label>
                    </div>
                    <button id="downloadSectionDxfBtn" class="modal-mobile-hidden">DXF</button>
                    <button class="modal-close">&times;</button>
                </div>
            </div>
            <div class="modal-body"><canvas id="sectionPlot"></canvas></div>
        </div>
    </div>
    <div class="drop-overlay"><p>ã“ã“ã«GPX/CSV/ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‰ãƒ­ãƒƒãƒ—</p></div>

    <div id="coord-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; height: auto;">
            <div class="modal-header"><h3>åº§æ¨™ç³»ã®ç¢ºèª</h3></div>
            <div class="modal-body" style="padding: 20px;">
                <p>XYåº§æ¨™ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚<br>å¤‰æ›ã«ä½¿ç”¨ã™ã‚‹åº§æ¨™ç³»ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
                <div class="control-group" style="margin-top: 15px;">
                    <label for="modal-coord-system">åº§æ¨™ç³»:</label>
                    <select id="modal-coord-system" style="padding: 8px;"></select>
                </div>
            </div>
            <div class="modal-footer">
                <button id="coord-modal-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="coord-modal-ok" class="ok-btn">æ±ºå®š</button>
            </div>
        </div>
    </div>

    <div id="section-by-coords-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; height: auto;">
            <div class="modal-header"><h3>åº§æ¨™æŒ‡å®šã«ã‚ˆã‚‹æ–­é¢ç·šä½œæˆ</h3><button class="modal-close">&times;</button></div>
            <div class="modal-body" style="padding: 20px;">
                <p style="font-size:0.9em; margin-bottom:15px;">æ–­é¢ç·šã®å§‹ç‚¹ã¨çµ‚ç‚¹ã®åº§æ¨™ï¼ˆXYãƒ—ãƒ­ãƒƒãƒˆã®è»¸ã«å¯¾å¿œï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="control-group">
                        <label for="section-start-y">å§‹ç‚¹ Yåº§æ¨™ (m)</label>
                        <input type="number" id="section-start-y" placeholder="ä¾‹: 12345.67" style="padding: 8px;">
                    </div>
                    <div class="control-group">
                        <label for="section-start-x">å§‹ç‚¹ Xåº§æ¨™ (m)</label>
                        <input type="number" id="section-start-x" placeholder="ä¾‹: -5432.10" style="padding: 8px;">
                    </div>
                    <div class="control-group">
                        <label for="section-end-y">çµ‚ç‚¹ Yåº§æ¨™ (m)</label>
                        <input type="number" id="section-end-y" placeholder="ä¾‹: 12365.43" style="padding: 8px;">
                    </div>
                    <div class="control-group">
                        <label for="section-end-x">çµ‚ç‚¹ Xåº§æ¨™ (m)</label>
                        <input type="number" id="section-end-x" placeholder="ä¾‹: -5442.20" style="padding: 8px;">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="section-coords-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="section-coords-ok" class="ok-btn">ä½œæˆ</button>
            </div>
        </div>
    </div>

    <div id="text-import-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; height: 500px;">
            <div class="modal-header">
                <h3>ãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p style="font-size: 0.9em; margin-bottom: 10px; flex-shrink: 0;">
                    Excelãªã©ã‹ã‚‰æ¸¬ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚(ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š/ã‚¿ãƒ–åŒºåˆ‡ã‚Šã«å¯¾å¿œ)<br>
                    æƒ³å®šã•ã‚Œã‚‹åˆ—: <b>æ¸¬ç‚¹å, (ç·¯åº¦, çµŒåº¦ | Xåº§æ¨™, Yåº§æ¨™), æ¨™é«˜(ã‚¢ãƒ³ãƒ†ãƒŠé«˜)</b>
                </p>
                <textarea id="text-import-textarea" placeholder="ä¾‹:&#10;P1, 35.123, 139.456, 50.1&#10;P2, 1234.5, 5678.9, 33.3 (X, Y)&#10;..."></textarea>
            </div>
            <div class="modal-footer">
                <button id="text-import-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="text-import-ok" class="ok-btn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            </div>
        </div>
    </div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <h4>ã¯ã˜ã‚ã«</h4>
                <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€GNSSæ¸¬é‡ãªã©ã§å–å¾—ã—ãŸæ¸¬é‡ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§å¯è¦–åŒ–ã—ã€ç°¡å˜ãªè§£æã‚„æ–­é¢å›³ä½œæˆã‚’è¡Œã†ãŸã‚ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
                
                <h4>åŸºæœ¬çš„ãªä½¿ã„æ–¹ (3ã‚¹ãƒ†ãƒƒãƒ—)</h4>
                <ol>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</strong><br>
                        æ“ä½œãƒ‘ãƒãƒ«ã®ãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ç”»é¢ã¸ã®ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
                        <ul>
                            <li><b>ğŸ“‚GPX</b>: æ¨™æº–çš„ãªGPXãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¦ã‚§ã‚¤ãƒã‚¤ãƒ³ãƒˆ(wpt)ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚</li>
                            <li><b>ğŸ§¾CSV/TXT</b>: ã‚«ãƒ³ãƒã¾ãŸã¯ã‚¿ãƒ–åŒºåˆ‡ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                            <li><b>ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆ</b>: Excelãªã©ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥è²¼ã‚Šä»˜ã‘ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                            <li><b>CSV/TXTã®æ›¸å¼</b>: `æ¸¬ç‚¹å, Xåº§æ¨™(ã¾ãŸã¯ç·¯åº¦), Yåº§æ¨™(ã¾ãŸã¯çµŒåº¦), ã‚¢ãƒ³ãƒ†ãƒŠé«˜` ã®é †ã§ãƒ‡ãƒ¼ã‚¿ã‚’ç”¨æ„ã—ã¦ãã ã•ã„ã€‚XYåº§æ¨™ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã‚‹ã¨ã€åº§æ¨™ç³»ã‚’é¸æŠã™ã‚‹ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªã¨æ“ä½œ</strong><br>
                        ãƒ‡ãƒ¼ã‚¿ã¯å·¦ã®ã€Œãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒãƒ«ã€ã¨å³ã®ã€ŒğŸ—ºï¸ åœ°å›³ã€ã€ŒğŸ“ˆXYãƒ—ãƒ­ãƒƒãƒˆã€ãªã©ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
                        <ul>
                            <li><b>ãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒãƒ«</b>: ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®è¡¨ç¤º/éè¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆã‚„å‰Šé™¤ãŒã§ãã¾ã™ã€‚</li>
                            <li><b>ãƒ†ãƒ¼ãƒ–ãƒ«</b>: æ¸¬ç‚¹ã®ä¸€è¦§ã§ã™ã€‚è¡Œã®ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆã€æ¸¬ç‚¹åã‚„ã‚¢ãƒ³ãƒ†ãƒŠé«˜ã®ã‚»ãƒ«ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨å€¤ã‚’ç›´æ¥ç·¨é›†ã§ãã¾ã™ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã€ŒğŸ‘ï¸ã€ãƒœã‚¿ãƒ³ã§å€‹åˆ¥ã®æ¸¬ç‚¹ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤ºï¼ˆé–“å¼•ãï¼‰ã§ãã¾ã™ã€‚</li>
                            <li><b>ğŸ—ºï¸åœ°å›³</b>: åœ°ç†é™¢åœ°å›³ä¸Šã«æ¸¬ç‚¹ã®ä½ç½®ãŒãƒ—ãƒ­ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨è©³ç´°æƒ…å ±ã‚’ç¢ºèªã§ãã€ãã“ã‹ã‚‰éè¡¨ç¤ºã«ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚</li>
                            <li><b>ğŸ“ˆXY/ğŸ“‰XZ/YZãƒ—ãƒ­ãƒƒãƒˆ</b>: å„å¹³é¢ã§ã®ä½ç½®é–¢ä¿‚ã‚’ç¢ºèªã§ãã¾ã™ã€‚ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ï¼ˆç§»å‹•ï¼‰ãŒã§ãã¾ã™ã€‚XYãƒ—ãƒ­ãƒƒãƒˆã§ã¯ç‚¹ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦éè¡¨ç¤ºã«ã§ãã¾ã™ã€‚</li>
                            <li><b>ğŸŒ3Dãƒ—ãƒ­ãƒƒãƒˆ</b>: æ¸¬ç‚¹ã‚’3æ¬¡å…ƒç©ºé–“ã«ãƒ—ãƒ­ãƒƒãƒˆã—ã¾ã™ã€‚ãƒã‚¦ã‚¹æ“ä½œã§è‡ªç”±ã«å›è»¢ãƒ»ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ãŒå¯èƒ½ã§ã™ã€‚</li>
                            <li><b>â†©ï¸å…ƒã«æˆ»ã™</b>: ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã€Œæˆ»ã™ã€ãƒœã‚¿ãƒ³ã§ã€ç›´å‰ã®éè¡¨ç¤ºæ“ä½œã‚’å–ã‚Šæ¶ˆã›ã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li>
                        <strong>ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</strong><br>
                        æ“ä½œãƒ‘ãƒãƒ«ã®ã€ŒCSVã€ã€ŒDXFã€ãƒœã‚¿ãƒ³ã‹ã‚‰ã€è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å…¨æ¸¬ç‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)
                    </li>
                </ol>

                <h4>å¿œç”¨æ©Ÿèƒ½: æ–­é¢å›³ã®ä½œæˆ</h4>
                <ol>
                    <li>XYãƒ—ãƒ­ãƒƒãƒˆã‚¿ãƒ–ã®<b>ã€Œæ–­é¢ç·šä½œæˆã€</b>ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã€ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚</li>
                    <li>
                        <b>æ–­é¢ç·šã®å®šç¾©</b>:
                        <ul>
                            <li><b>ä»»æ„ã®2ç‚¹</b>: ãƒ—ãƒ­ãƒƒãƒˆä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµã¶ç·šã‚’ä½œæˆã—ã¾ã™ã€‚</li>
                            <li><b>é‰›ç›´/æ°´å¹³</b>: ãƒ—ãƒ­ãƒƒãƒˆä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ãã®ä½ç½®ã‚’é€šã‚‹å‚ç›´ç·šã¾ãŸã¯æ°´å¹³ç·šã‚’ä½œæˆã—ã¾ã™ã€‚</li>
                            <li><b>åº§æ¨™æŒ‡å®š</b>: ã€Œâ‘£åº§æ¨™æŒ‡å®šã€ã‚’é¸æŠã—ã€è¡¨ç¤ºã•ã‚Œã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«å§‹ç‚¹ã¨çµ‚ç‚¹ã®XYåº§æ¨™ã‚’ç›´æ¥å…¥åŠ›ã—ã¦æ–­é¢ç·šã‚’å®šç¾©ã—ã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li><b>æ¸¬ç‚¹ã®é¸æŠ</b>: æ–­é¢ç·šãŒå®šç¾©ã•ã‚Œã‚‹ã¨ã€è¨­å®šã—ãŸã€Œæ–­é¢å¹…ã€ã«å«ã¾ã‚Œã‚‹æ¸¬ç‚¹ãŒè‡ªå‹•çš„ã«é¸æŠã•ã‚Œã¾ã™ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ä¸Šã§ç´«è‰²ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰ã€‚ãƒ—ãƒ­ãƒƒãƒˆä¸Šã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã€æ‰‹å‹•ã§æ¸¬ç‚¹ã‚’è¿½åŠ ãƒ»å‰Šé™¤ã§ãã¾ã™ã€‚</li>
                    <li><b>æ–­é¢å›³ã®ä½œæˆ</b>: æ¸¬ç‚¹ãŒ2ã¤ä»¥ä¸Šé¸æŠã•ã‚ŒãŸçŠ¶æ…‹ã§<b>ã€Œæ–­é¢å›³ä½œæˆã€</b>ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€æ–­é¢å›³ãŒãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                     <li><b>æ–­é¢å›³ã®ç¨®é¡</b>: ã€ŒæŠ•å½±æ–­é¢ã€ã¨ã€Œæ¸¬ç‚¹é€£çµæ–­é¢ã€ã‚’åˆ‡ã‚Šæ›¿ãˆã¦è¡¨ç¤ºã§ãã¾ã™ã€‚</li>
                    <li><b>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</b>: æ–­é¢å›³ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‹ã‚‰ã€æ–­é¢ãƒ‡ãƒ¼ã‚¿ã‚’CSVã¾ãŸã¯DXFå½¢å¼ã§ä¿å­˜ã§ãã¾ã™ã€‚<br>DXFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã§ã¯ã€ã€Œæ–­é¢å›³ã®ã¿ã€ã¾ãŸã¯ã€Œç¾åœ¨ã®å¹³é¢å›³ã¨æ–­é¢å›³ã®ä¸¡æ–¹ã€ã‚’é¸æŠã—ã¦å‡ºåŠ›ã§ãã¾ã™ã€‚(â€»ãƒ¢ãƒã‚¤ãƒ«éå¯¾å¿œ)</li>
                </ol>
                
                <h4>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ©Ÿèƒ½</h4>
                <p>ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã‚ã‚‹<b>ã€ŒğŸ’¾ä¿å­˜ã€</b>ãƒœã‚¿ãƒ³ã§ç¾åœ¨ã®ä½œæ¥­çŠ¶æ…‹ã‚’ `.gsv` ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ã€‚ã“ã‚Œã«ã¯èª­ã¿è¾¼ã‚“ã GPXã€CSVã€TXTã€ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãƒ‡ãƒ¼ã‚¿ã€ç·¨é›†å†…å®¹ã€è¡¨ç¤ºè¨­å®šã€éè¡¨ç¤ºè¨­å®šãªã©ãŒã™ã¹ã¦å«ã¾ã‚Œã¾ã™ã€‚å¾Œã§<b>ã€ŒğŸ“¥èª­è¾¼ã€</b>ãƒœã‚¿ãƒ³ã‹ã‚‰ä½œæ¥­ã‚’å†é–‹ã§ãã¾ã™ã€‚</p>
            </div>
        </div>
    </div>
    
    <div id="cluster-settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; height: auto;">
            <div class="modal-header">
                <h3>è¿‘æ¥ç‚¹ã®çµ±è¨ˆå‡¦ç† - é–¾å€¤è¨­å®š</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <p style="font-size: 0.9em; margin-bottom: 15px;">
                    åŒã˜åœ°ç‚¹ã¨è¦‹ãªã™åº§æ¨™ã®è¨±å®¹ç¯„å›²ï¼ˆé–¾å€¤ï¼‰ã‚’ã‚»ãƒ³ãƒãƒ¡ãƒ¼ãƒˆãƒ«(cm)ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
                </p>
                <div class="control-group" style="margin-bottom: 10px;">
                    <label for="xy-tolerance">æ°´å¹³è·é›¢ (XY) ã®é–¾å€¤ (cm)</label>
                    <input type="number" id="xy-tolerance" value="10.0" step="1" style="width: 100%; padding: 8px;">
                </div>
                <div class="control-group">
                    <label for="z-tolerance">æ¨™é«˜ (Z) ã®é–¾å€¤ (cm)</label>
                    <input type="number" id="z-tolerance" value="20.0" step="1" style="width: 100%; padding: 8px;">
                </div>
            </div>
            <div class="modal-footer">
                <button id="cluster-settings-cancel" class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="cluster-settings-ok" class="ok-btn">å®Ÿè¡Œ</button>
            </div>
        </div>
    </div>
    
    <div id="stats-modal" class="draggable">
        <div class="modal-header">
            <h3 style="margin-right: auto;">è¿‘æ¥ç‚¹ã®çµ±è¨ˆå‡¦ç†çµæœ</h3>
            <div style="display: flex; gap: 10px; align-items:center;">
                <button id="addAveragesBtn" title="è¨ˆç®—ã•ã‚ŒãŸå¹³å‡å€¤ã¨ã€ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œãªã‹ã£ãŸå…ƒã®ç‚¹ã‚’æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¨ã—ã¦è¿½åŠ ã—ã¾ã™">å¹³å‡å€¤ã¨å¯¾è±¡å¤–ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ </button>
                <button id="downloadStatsCsvBtn" title="è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹çµ±è¨ˆçµæœã‚’CSVãƒ•ã‚¡ã‚¤ãƒ«ã§ä¿å­˜ã—ã¾ã™">CSV</button>
                <button class="modal-close" title="é–‰ã˜ã‚‹">&times;</button>
            </div>
        </div>
        <div class="modal-body" id="stats-modal-body">
            <!-- çµ±è¨ˆçµæœã®ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã“ã“ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
        </div>
    </div>


    <footer class="legal-notice">
      <div id="lastUpdated"></div>
      <div id="legal-toggle">å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)</div>
      <div id="legal-details">
        <p class="copyright" style="font-weight: bold;">Copyright &copy; 2025 (æ ª)åœ°åœç·åˆã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ All Rights Reserved.</p>
        <p class="developer" style="font-size: 11px;">Developed by: Naoya.Onozato</p>
        <p>æœ¬ã‚µãƒ¼ãƒ“ã‚¹ã®åˆ©ç”¨ã«ã‚ˆã£ã¦ç”Ÿã˜ãŸã„ã‹ãªã‚‹æå®³ã«ã¤ã„ã¦ã‚‚ã€ä½œæˆè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
        <p>æœ¬ã‚µãƒ¼ãƒ“ã‚¹ã¯ä»¥ä¸‹ã®ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŠã‚ˆã³å…¬çš„æ©Ÿé–¢ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™:<br>- åœ°å›³ãƒ‡ãƒ¼ã‚¿: Â© å›½åœŸåœ°ç†é™¢<br>- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª: Leaflet, Chart.js, SortableJS, proj4js, Plotly.js</p>
      </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <script>
        // --- (JavaScript) ---
        // --- (JavaScript) ---
        let map, polylineLayer, sortableInstance, chartInstance, xzChartInstance, yzChartInstance, sectionChartInstance, mapSectionLine;
        let loadedFiles = {}, activePoints = [], currentSectionData = {}, lastSectionCoords = null, lastDefinedSectionLinePoints = null;
        let isSectionMode = false, isSectionLineDefined = false, sectionLineStart = null;
        let pointsInLastSectionIds = [];
        let isDrawingSectionLine = false;
        let tempCsvContent = null;
        let tempCsvFileName = null;
        let textImportCounter = 1;
        let wasXyAspectRatioChecked = false;
        let wasXzAspectRatioChecked = false;
        let wasYzAspectRatioChecked = false;
        let statsLayerGroup = null; 
        let lastClusterResults = null;
        let lastClusteredPointIds = new Set();
        let actionHistory = [];
        let contextMenuPointId = null;
        
        const COLORS = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#fabebe', '#008080', '#e6beff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075'];
        const getMean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
        const getMedian = arr => { const sorted = [...arr].sort((a, b) => a - b); const mid = Math.floor(sorted.length / 2); return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2; };
        const getStdDev = (arr, mean) => { if (arr.length < 2) return 0; const sqDiffs = arr.map(val => (val - mean) ** 2); return Math.sqrt(getMean(sqDiffs)); };
        const findLongestCommonPrefix = (strs) => { if (!strs || strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); if (prefix === '') return ''; } } return prefix.replace(/[\s-_\.\+]+$/, ''); };

        const coordinateSystems = [ {num:1, lat0:33, lon0:129.5, epsg:6669}, {num:2, lat0:33, lon0:131, epsg:6670}, {num:3, lat0:36, lon0:132.1666667, epsg:6671}, {num:4, lat0:33, lon0:133.5, epsg:6672}, {num:5, lat0:36, lon0:134.3333333, epsg:6673}, {num:6, lat0:36, lon0:136, epsg:6674}, {num:7, lat0:36, lon0:137.1666667, epsg:6675}, {num:8, lat0:36, lon0:138.5, epsg:6676}, {num:9, lat0:36, lon0:139.8333333, epsg:6677}, {num:10, lat0:40, lon0:140.8333333, epsg:6678}, {num:11, lat0:44, lon0:140.25, epsg:6679}, {num:12, lat0:44, lon0:142.25, epsg:6680}, {num:13, lat0:44, lon0:144.25, epsg:6681}, {num:14, lat0:26, lon0:142, epsg:6682}, {num:15, lat0:26, lon0:127.5, epsg:6683}, {num:16, lat0:26, lon0:124, epsg:6684}, {num:17, lat0:26, lon0:131, epsg:6685}, {num:18, lat0:20, lon0:136, epsg:6686}, {num:19, lat0:26, lon0:154, epsg:6687} ];
        function parseCSVLine(line) { const result = []; let current = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"' && (i === 0 || line[i-1] !== '\\')) { if (inQuotes && line[i+1] === '"') { current += '"'; i++; } else { inQuotes = !inQuotes; } } else if ((char === ',' || char === '\t') && !inQuotes) { result.push(current.trim().replace(/^"|"$/g, '')); current = ''; } else { current += char; } } result.push(current.trim().replace(/^"|"$/g, '')); return result; }
        function latLonToXY(lat, lon, systemId) { const system = coordinateSystems.find(s => s.num == systemId); if (!system) throw new Error(`åº§æ¨™ç³» ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`); const [y, x] = proj4('EPSG:4326', `EPSG:${system.epsg}`, [lon, lat]); return { x, y }; }
        function xyToLatLon(x, y, systemId) { const system = coordinateSystems.find(s => s.num == systemId); if (!system) throw new Error(`åº§æ¨™ç³» ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`); const [lon, lat] = proj4(`EPSG:${system.epsg}`, 'EPSG:4326', [y, x]); return { lat, lon }; }
        function initMap() { const gsiStd = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', { attribution: 'Â© GSI' }); map = L.map('map', { layers: [gsiStd] }).setView([36.2, 139.0], 5); L.control.layers({ "åœ°ç†é™¢åœ°å›³": gsiStd, "å†™çœŸ": L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/ort/{z}/{x}/{y}.jpg', { attribution: 'Â© GSI' }) }).addTo(map); L.control.scale({ imperial: false }).addTo(map); polylineLayer = L.layerGroup().addTo(map); }
        function parseGPX(xmlText, fileName) { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlText, 'text/xml'); const wpts = xmlDoc.getElementsByTagName('wpt'); const points = []; for (let i = 0; i < wpts.length; i++) { const wpt = wpts[i]; const getTagText = (p, t) => p.getElementsByTagName(t)[0]?.textContent || null; const d = { id: `${fileName}-gpx-${i}`, name: getTagText(wpt, 'name') || `P${points.length + 1}`, lat: parseFloat(wpt.getAttribute('lat')), lon: parseFloat(wpt.getAttribute('lon')), antennaHeight: parseFloat(getTagText(wpt, 'ele') || 0), time: getTagText(wpt, 'time') || '', cmtText: getTagText(wpt, 'cmt') || '', pointGeoidHeight: parseFloat(getTagText(wpt, 'geoidheight') || 0), geoidSystem: '', fixMode: '', ellipsoidHeight: null, eleDiff: null, fileName: fileName, modifiedFields: {}, isHidden: false }; const extensions = wpt.getElementsByTagName('extensions')[0]; if (extensions) { const measurement = extensions.getElementsByTagName('b:measurement')[0]; if (measurement) { d.geoidSystem = getTagText(measurement, 'b:geoidSystem') || ''; d.fixMode = getTagText(measurement, 'b:fixMode') || ''; } } if (d.cmtText) { const m = d.cmtText.match(/ellipsoidHeight=([\d\.-]+)/); if (m) d.ellipsoidHeight = parseFloat(m[1]); } if (d.ellipsoidHeight !== null && d.pointGeoidHeight !== null) { d.eleDiff = d.antennaHeight - (d.ellipsoidHeight - d.pointGeoidHeight); } points.push(d); } return points; }
        function processCsvPoints(csvText, fileName, coordSystemId) { const lines = csvText.trim().split(/\r?\n/); const headerLineTest = lines[0].toLowerCase(); const hasHeader = headerLineTest.includes('æ¸¬ç‚¹å') || headerLineTest.includes('name') || headerLineTest.includes('point'); const dataLines = hasHeader ? lines.slice(1) : lines; const points = []; for (let i = 0; i < dataLines.length; i++) { const values = parseCSVLine(dataLines[i]); if (values.length < 3 || values.some(v => v === '')) continue; const name = values[0]; const val1 = parseFloat(values[1]); const val2 = parseFloat(values[2]); const antennaHeight = values.length > 3 ? parseFloat(values[values.length - 1]) : 0; if (!name || isNaN(val1) || isNaN(val2) || isNaN(antennaHeight)) continue; let lat, lon; if (Math.abs(val1) <= 90 && Math.abs(val2) <= 180) { lat = val1; lon = val2; } else { if (!coordSystemId) { throw new Error("XYåº§æ¨™ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸãŒã€æœ‰åŠ¹ãªåº§æ¨™ç³»ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); } const easting = val1; const northing = val2; const latLon = xyToLatLon(easting, northing, coordSystemId); lat = latLon.lat; lon = latLon.lon; } if (isNaN(lat) || isNaN(lon)) { console.warn(`è¡Œ ${i+1} ã®ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã‹ã€åº§æ¨™ç³»ã®è¨­å®šãŒé–“é•ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™: ${dataLines[i]}`); continue; } points.push({ id: `${fileName}-csv-${i}`, name: name, lat: lat, lon: lon, antennaHeight: antennaHeight, time: '', cmtText: `(CSV Import)`, pointGeoidHeight: 0, ellipsoidHeight: null, eleDiff: null, fileName: fileName, modifiedFields: {}, isHidden: false }); } return points; }
        function showCoordSystemModal(csvContent, fileName) { tempCsvContent = csvContent; tempCsvFileName = fileName; const modal = document.getElementById('coord-modal'); const mainSelect = document.getElementById('coordSystem'); const modalSelect = document.getElementById('modal-coord-system'); modalSelect.innerHTML = mainSelect.innerHTML; modalSelect.value = mainSelect.value; modal.style.display = 'flex'; }
        function parseCSV(csvText, fileName) { const lines = csvText.trim().split(/\r?\n/); if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) throw new Error("ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚"); const headerLineTest = lines[0].toLowerCase(); const hasHeader = headerLineTest.includes('æ¸¬ç‚¹å') || headerLineTest.includes('name') || headerLineTest.includes('point'); const lineToCheck = hasHeader && lines.length > 1 ? lines[1] : lines[0]; if (!lineToCheck) { throw new Error("ãƒ‡ãƒ¼ã‚¿è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); } const valuesToCheck = parseCSVLine(lineToCheck); if (valuesToCheck.length < 3) throw new Error("ãƒ‡ãƒ¼ã‚¿ã¯å°‘ãªãã¨ã‚‚3åˆ—ï¼ˆæ¸¬ç‚¹å, X/ç·¯åº¦, Y/çµŒåº¦ï¼‰å¿…è¦ã§ã™ã€‚"); const val1 = parseFloat(valuesToCheck[1]); const val2 = parseFloat(valuesToCheck[2]); const isLatLon = !isNaN(val1) && !isNaN(val2) && Math.abs(val1) <= 90 && Math.abs(val2) <= 180; if (isLatLon) { const coordSystemId = document.getElementById('coordSystem').value; return processCsvPoints(csvText, fileName, coordSystemId); } else { showCoordSystemModal(csvText, fileName); return null; } }
        function processFiles(files) { Array.from(files).forEach(file => { const reader = new FileReader(); const fileType = file.name.toLowerCase().endsWith('.gpx') ? 'gpx' : (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt') ? 'csv' : null); if (!fileType) return; reader.onload = (e) => { try { const content = e.target.result; let points = []; if (fileType === 'gpx') { points = parseGPX(content, file.name); if(points.length === 0) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã«æ¸¬ç‚¹(<wpt>)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`); return; } } else { points = parseCSV(content, file.name); if (points === null) return; if(points.length === 0) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); return; } } loadedFiles[file.name] = { points, visible: true, color: COLORS[Object.keys(loadedFiles).length % COLORS.length], gpxContent: fileType === 'gpx' ? content : null }; updateFileListUI(); updateUI(); } catch (err) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«è§£æã‚¨ãƒ©ãƒ¼ (${file.name}): ${err.message}`); } }; reader.readAsText(file); }); }
        
        function togglePointVisibility(pointId, recordAction = true) {
            let targetPoint = null;
            for (const fileName in loadedFiles) {
                const p = loadedFiles[fileName].points.find(pt => pt.id === pointId);
                if (p) { targetPoint = p; break; }
            }
            if (targetPoint) {
                if (recordAction) {
                    actionHistory.push({ action: 'toggleVisibility', pointId: targetPoint.id, wasHidden: targetPoint.isHidden });
                    document.getElementById('undoBtn').disabled = false;
                }
                targetPoint.isHidden = !targetPoint.isHidden;
                updateUI();
            }
        }
        function undoLastAction() {
            if (actionHistory.length === 0) return;
            const lastAction = actionHistory.pop();
            if (lastAction.action === 'toggleVisibility') {
                togglePointVisibility(lastAction.pointId, false);
            }
            document.getElementById('undoBtn').disabled = actionHistory.length === 0;
        }

        function updateUI() {
            activePoints = [];
            for (const f in loadedFiles) {
                if (loadedFiles[f].visible) {
                    activePoints.push(...loadedFiles[f].points.filter(p => !p.isHidden));
                }
            }
            rerenderUI();
        }
        function rerenderUI(highlightPointId = null) {
            const sys = document.getElementById('coordSystem').value;
            const pole = parseFloat(document.getElementById('poleHeight').value);
            const allPointsWithState = [];
            for (const f in loadedFiles) {
                if (loadedFiles[f].visible) { allPointsWithState.push(...loadedFiles[f].points); }
            }
            const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole }));
            displayTable(allPointsWithState.sort((a,b) => a.fileName.localeCompare(b.fileName)), highlightPointId);
            addMarkersAndLine(processedPoints);
            displayXYPlot(processedPoints, highlightPointId);
            displayXZPlot(processedPoints, highlightPointId);
            displayYZPlot(processedPoints, highlightPointId);
            display3DPlot(processedPoints, highlightPointId);
            const hasPoints = activePoints.length > 0;
            document.getElementById('downloadCsvBtn').style.visibility = hasPoints ? 'visible' : 'hidden';
            document.getElementById('downloadDxfBtn').style.visibility = hasPoints ? 'visible' : 'hidden';
            if (Object.keys(loadedFiles).length === 0) {
                document.getElementById('tableContainer').innerHTML = `<div class="loading" style="text-align:center; padding-top: 50px;">GPX/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>`;
            }
        }
        function displayTable(points, highlightPointId) { let tableHTML = `<table><thead><tr><th><span title="ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ">&#x2195;</span></th><th></th><th class="mobile-hidden-col">ãƒ•ã‚¡ã‚¤ãƒ«å</th><th title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†">æ¸¬ç‚¹å</th><th class="mobile-hidden-col">æ¸¬å®šæ—¥æ™‚</th><th>ç·¯åº¦</th><th>çµŒåº¦</th><th>X (m)</th><th>Y (m)</th><th title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†">ã‚¢ãƒ³ãƒ†ãƒŠé«˜</th><th>è£œæ­£å¾Œæ¨™é«˜</th></tr></thead><tbody>`; if (points.length === 0) { tableHTML = `<div class="loading" style="text-align:center; padding-top: 50px;">è¡¨ç¤ºã™ã‚‹æ¸¬ç‚¹ãŒã‚ã‚Šã¾ã›ã‚“</div>`; } else { const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); points.forEach(p => { const highlightClass = p.id === highlightPointId ? 'highlighted' : ''; const hiddenClass = p.isHidden ? 'hidden-row' : ''; const nameModifiedClass = p.modifiedFields?.name ? 'modified-cell' : ''; const antennaHeightModifiedClass = p.modifiedFields?.antennaHeight ? 'modified-cell' : ''; const inSectionClass = pointsInLastSectionIds.includes(p.id) ? 'in-section' : ''; const coords = latLonToXY(p.lat, p.lon, sys); const correctedEle = p.antennaHeight - pole; tableHTML += `<tr data-id="${p.id}" class="${highlightClass} ${inSectionClass} ${hiddenClass}"> <td class="drag-handle">&#x2195;</td><td><span class="visibility-toggle" title="è¡¨ç¤º/éè¡¨ç¤º" onclick="togglePointVisibility('${p.id}')">${p.isHidden ? 'ğŸ™ˆ' : 'ğŸ‘ï¸'}</span></td><td class="mobile-hidden-col">${p.fileName}</td> <td class="editable-cell ${nameModifiedClass}" data-field="name"><strong>${p.name}</strong></td> <td class="mobile-hidden-col">${p.time ? new Date(p.time).toLocaleString('ja-JP', { hour12: false }).replace(/\//g, '-') : 'N/A'}</td> <td>${p.lat.toFixed(9)}</td><td>${p.lon.toFixed(9)}</td><td>${coords.x.toFixed(3)}</td><td>${coords.y.toFixed(3)}</td> <td class="editable-cell ${antennaHeightModifiedClass}" data-field="antennaHeight"><strong>${p.antennaHeight.toFixed(3)}</strong></td> <td>${correctedEle.toFixed(3)}</td></tr>`; }); tableHTML += `</tbody></table>`; } document.getElementById('tableContainer').innerHTML = tableHTML; const tbody = document.querySelector("#tableContainer tbody"); if (tbody) { if (sortableInstance) sortableInstance.destroy(); sortableInstance = Sortable.create(tbody, { handle: '.drag-handle', animation: 150, onEnd: (evt) => { const item = activePoints.splice(evt.oldIndex, 1)[0]; activePoints.splice(evt.newIndex, 0, item); rerenderUI(); } }); } }
        Chart.register(window.ChartZoom);
        const xyPlotAspectRatioPlugin = { id: 'xyPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('aspectRatioToggle').checked) return; const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };
        const xzPlotAspectRatioPlugin = { id: 'xzPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('xzAspectRatioToggle').checked) return; const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };
        const yzPlotAspectRatioPlugin = { id: 'yzPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('yzAspectRatioToggle').checked) return; const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };
        const scaleBarPlugin = { id: 'scaleBar', afterDraw: (chart) => { const ctx = chart.ctx; const xAxis = chart.scales.x; const chartArea = chart.chartArea; if (!xAxis || xAxis.min === undefined || xAxis.max === undefined || !chartArea) return; const maxPixelWidth = 100; const viewableRange = xAxis.max - xAxis.min; const maxRealWorldDistance = viewableRange * (maxPixelWidth / xAxis.width); if (maxRealWorldDistance <= 0) return; const magnitude = Math.pow(10, Math.floor(Math.log10(maxRealWorldDistance))); const possibleSteps = [magnitude, magnitude / 2, magnitude / 5, magnitude / 10, magnitude / 20, magnitude / 50, magnitude/100]; const niceDistance = possibleSteps.find(step => (step / viewableRange) * xAxis.width > 20) || possibleSteps[possibleSteps.length - 1]; const scalePixelWidth = (niceDistance / viewableRange) * xAxis.width; const xPos = chartArea.left + 20; const yPos = chartArea.bottom - 20; let label; if (niceDistance >= 1) { label = `${niceDistance.toFixed(0)} m`; } else if (niceDistance >= 0.01) { label = `${(niceDistance * 100).toFixed(0)} cm`; } else { label = `${(niceDistance * 1000).toFixed(0)} mm`; } ctx.save(); ctx.strokeStyle = '#333'; ctx.fillStyle = '#333'; ctx.lineWidth = 2; ctx.font = '12px "Segoe UI", Arial, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.beginPath(); ctx.moveTo(xPos, yPos); ctx.lineTo(xPos + scalePixelWidth, yPos); ctx.moveTo(xPos, yPos - 5); ctx.lineTo(xPos, yPos + 5); ctx.moveTo(xPos + scalePixelWidth, yPos - 5); ctx.lineTo(xPos + scalePixelWidth, yPos + 5); ctx.stroke(); ctx.fillText(label, xPos + scalePixelWidth / 2, yPos - 8); ctx.restore(); } };
        
        // ã‚°ãƒ©ãƒ•ãƒ›ãƒãƒ¼æ™‚ã«çµ±è¨ˆãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹å…±é€šé–¢æ•°
        const highlightStatsTableRowOnHover = (event, elements, chart) => {
            const statsTableRows = document.querySelectorAll('#stats-modal-body tr');
            statsTableRows.forEach(row => row.classList.remove('highlighted'));

            if (elements.length > 0) {
                const element = elements[0];
                const dataset = chart.data.datasets[element.datasetIndex];
                
                if (dataset.label === 'å¹³å‡å€¤') {
                    const pointIndex = element.index;
                    const targetRow = document.querySelector(`#stats-modal-body tr[data-group-index="${pointIndex}"]`);
                    if (targetRow) {
                        targetRow.classList.add('highlighted');
                    }
                }
            }
        };

        function displayXYPlot(points, highlightPointId) { const ctx = document.getElementById('xyPlot'); if (points.length === 0 && !lastClusterResults) { if (chartInstance) { chartInstance.destroy(); chartInstance = null; } return; } const datasets = {}, lineDatasets = {}; points.forEach((p, index) => { if (!datasets[p.fileName]) { datasets[p.fileName] = { type: 'scatter', label: p.fileName, data: [], pointRadius: [], pointHoverRadius: 8, backgroundColor: [], borderColor: [], borderWidth: [], originalIndices: [] }; lineDatasets[p.fileName] = { type: 'line', label: p.fileName + '-line', data: [], borderColor: loadedFiles[p.fileName]?.color || '#000', borderWidth: 1, pointRadius: 0, showInLegend: false }; } datasets[p.fileName].data.push({ x: p.y, y: p.x }); if (p.id === highlightPointId) { datasets[p.fileName].pointRadius.push(10); datasets[p.fileName].backgroundColor.push('#ff0000'); datasets[p.fileName].borderColor.push('#000000'); datasets[p.fileName].borderWidth.push(2); } else if (pointsInLastSectionIds.includes(p.id)) { datasets[p.fileName].pointRadius.push(6); datasets[p.fileName].backgroundColor.push('#c79fef'); datasets[p.fileName].borderColor.push('#5d3d7e'); datasets[p.fileName].borderWidth.push(1); } else { datasets[p.fileName].pointRadius.push(5); datasets[p.fileName].backgroundColor.push(loadedFiles[p.fileName]?.color + 'B3' || '#000000B3'); datasets[p.fileName].borderColor.push(loadedFiles[p.fileName]?.color || '#000'); datasets[p.fileName].borderWidth.push(1); } datasets[p.fileName].originalIndices.push(index); lineDatasets[p.fileName].data.push({ x: p.y, y: p.x }); }); let finalDatasets = document.getElementById('toggleLineOnPlot').checked ? [...Object.values(datasets), ...Object.values(lineDatasets)] : Object.values(datasets); if(lastClusterResults) { const avgDataset = { type: 'scatter', label: 'å¹³å‡å€¤', data: lastClusterResults.map(r => ({x: r.meanY, y: r.meanX})), pointStyle: 'circle', radius: 8, hoverRadius: 12, backgroundColor: lastClusterResults.map(r => r.color), borderColor: lastClusterResults.map(r => r.color), borderWidth: 2 }; finalDatasets.push(avgDataset); } const annotations = {}; if (isSectionLineDefined && lastDefinedSectionLinePoints) { const line = lastDefinedSectionLinePoints; const p1 = line[0]; const p2 = line[line.length - 1]; annotations.sectionLine = { type: 'line', xMin: p1.x, yMin: p1.y, xMax: p2.x, yMax: p2.y, borderColor: 'red', borderWidth: 2 }; } if (chartInstance) { chartInstance.data.datasets = finalDatasets; chartInstance.options.plugins.annotation.annotations = annotations; chartInstance.update(); } else { chartInstance = new Chart(ctx, { data: { datasets: finalDatasets }, plugins: [xyPlotAspectRatioPlugin, scaleBarPlugin], options: { animation: false, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Yåº§æ¨™ (m)' } }, y: { title: { display: true, text: 'Xåº§æ¨™ (m)' } } }, onHover: (event, elements) => highlightStatsTableRowOnHover(event, elements, chartInstance), plugins: { annotation: { annotations }, tooltip: { callbacks: { label: (ctx) => { if (ctx.dataset.label === 'å¹³å‡å€¤') return `${lastClusterResults[ctx.dataIndex].groupId}: (Y=${ctx.parsed.x.toFixed(4)}, X=${ctx.parsed.y.toFixed(4)})`; const pointIndex = Object.values(datasets).find(ds => ds.label === ctx.dataset.label).originalIndices[ctx.dataIndex]; return `${activePoints[pointIndex].name}: (Y=${ctx.parsed.x.toFixed(3)}, X=${ctx.parsed.y.toFixed(3)})`; }}}, zoom: { zoom: { wheel: { enabled: true }, mode: 'xy', onZoomStart: ({chart}) => { const t = document.getElementById('aspectRatioToggle'); wasXyAspectRatioChecked = t.checked; if (wasXyAspectRatioChecked) { t.checked = false; chart.update('none'); } }, onZoomComplete: ({chart}) => { if (wasXyAspectRatioChecked) { const t = document.getElementById('aspectRatioToggle'); t.checked = true; chart.update('none'); } wasXyAspectRatioChecked = false; } }, pan: { enabled: true, mode: 'xy' } } }, onClick: (evt) => { if (chartInstance.isZoomedOrPanned() && evt.native.detail === 2) { chartInstance.resetZoom(); return; } handlePlotClick(evt); }, } }); } }
        function displayXZPlot(points, highlightPointId) { const ctx = document.getElementById('xzPlot'); if (points.length === 0 && !lastClusterResults) { if (xzChartInstance) { xzChartInstance.destroy(); xzChartInstance = null; } return; } const datasets = {}, lineDatasets = {}; points.forEach((p, index) => { if (!datasets[p.fileName]) { datasets[p.fileName] = { type: 'scatter', label: p.fileName, data: [], pointRadius: [], pointHoverRadius: 8, backgroundColor: [], borderColor: [], borderWidth: [], originalIndices: [] }; lineDatasets[p.fileName] = { type: 'line', label: p.fileName + '-line', data: [], borderColor: loadedFiles[p.fileName]?.color || '#000', borderWidth: 1, pointRadius: 0, showInLegend: false }; } datasets[p.fileName].data.push({ x: p.x, y: p.correctedEle }); lineDatasets[p.fileName].data.push({ x: p.x, y: p.correctedEle }); if (p.id === highlightPointId) { datasets[p.fileName].pointRadius.push(10); datasets[p.fileName].backgroundColor.push('#ff0000'); datasets[p.fileName].borderColor.push('#000000'); datasets[p.fileName].borderWidth.push(2); } else if (pointsInLastSectionIds.includes(p.id)) { datasets[p.fileName].pointRadius.push(6); datasets[p.fileName].backgroundColor.push('#c79fef'); datasets[p.fileName].borderColor.push('#5d3d7e'); datasets[p.fileName].borderWidth.push(1); } else { datasets[p.fileName].pointRadius.push(5); datasets[p.fileName].backgroundColor.push(loadedFiles[p.fileName]?.color + 'B3' || '#000000B3'); datasets[p.fileName].borderColor.push(loadedFiles[p.fileName]?.color || '#000'); datasets[p.fileName].borderWidth.push(1); } datasets[p.fileName].originalIndices.push(index); }); let finalDatasets = document.getElementById('toggleLineOnXzPlot').checked ? [...Object.values(datasets), ...Object.values(lineDatasets)] : Object.values(datasets); if(lastClusterResults) { const avgDataset = { type: 'scatter', label: 'å¹³å‡å€¤', data: lastClusterResults.map(r => ({x: r.meanX, y: r.meanEle})), pointStyle: 'circle', radius: 8, hoverRadius: 12, backgroundColor: lastClusterResults.map(r => r.color), borderColor: lastClusterResults.map(r => r.color), borderWidth: 2 }; finalDatasets.push(avgDataset); } if (xzChartInstance) { xzChartInstance.data.datasets = finalDatasets; xzChartInstance.update(); } else { xzChartInstance = new Chart(ctx, { data: { datasets: finalDatasets }, plugins: [xzPlotAspectRatioPlugin, scaleBarPlugin], options: { animation: false, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Xåº§æ¨™ (m)' } }, y: { title: { display: true, text: 'è£œæ­£å¾Œæ¨™é«˜ (m)' } } }, onHover: (event, elements) => highlightStatsTableRowOnHover(event, elements, xzChartInstance), plugins: { tooltip: { callbacks: { label: (ctx) => { if (ctx.dataset.label === 'å¹³å‡å€¤') return `${lastClusterResults[ctx.dataIndex].groupId}: (X=${ctx.parsed.x.toFixed(4)}, Z=${ctx.parsed.y.toFixed(4)})`; const pointIndex = Object.values(datasets).find(ds => ds.label === ctx.dataset.label).originalIndices[ctx.dataIndex]; return `${activePoints[pointIndex].name}: (X=${ctx.parsed.x.toFixed(3)}, Z=${ctx.parsed.y.toFixed(3)})`; }}}, zoom: { zoom: { wheel: { enabled: true }, mode: 'xy', onZoomStart: ({chart}) => { const t = document.getElementById('xzAspectRatioToggle'); wasXzAspectRatioChecked = t.checked; if(wasXzAspectRatioChecked) { t.checked = false; chart.update('none'); } }, onZoomComplete: ({chart}) => { if (wasXzAspectRatioChecked) { const t = document.getElementById('xzAspectRatioToggle'); t.checked = true; chart.update('none'); } wasXzAspectRatioChecked = false; } }, pan: { enabled: true, mode: 'xy' } } }, onClick: (evt) => { if (isSectionMode) return; if (xzChartInstance.isZoomedOrPanned() && evt.native.detail === 2) { xzChartInstance.resetZoom(); return; } const elems = xzChartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true).filter(e => xzChartInstance.data.datasets[e.datasetIndex].label !== 'å¹³å‡å€¤'); if (elems.length > 0) { const elem = elems[0]; const ds = xzChartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; focusOnPoint(null, activePoints[ptIdx].id); } }, } }); } }
        function displayYZPlot(points, highlightPointId) { const ctx = document.getElementById('yzPlot'); if (points.length === 0 && !lastClusterResults) { if (yzChartInstance) { yzChartInstance.destroy(); yzChartInstance = null; } return; } const datasets = {}, lineDatasets = {}; points.forEach((p, index) => { if (!datasets[p.fileName]) { datasets[p.fileName] = { type: 'scatter', label: p.fileName, data: [], pointRadius: [], pointHoverRadius: 8, backgroundColor: [], borderColor: [], borderWidth: [], originalIndices: [] }; lineDatasets[p.fileName] = { type: 'line', label: p.fileName + '-line', data: [], borderColor: loadedFiles[p.fileName]?.color || '#000', borderWidth: 1, pointRadius: 0, showInLegend: false }; } datasets[p.fileName].data.push({ x: p.y, y: p.correctedEle }); lineDatasets[p.fileName].data.push({ x: p.y, y: p.correctedEle }); if (p.id === highlightPointId) { datasets[p.fileName].pointRadius.push(10); datasets[p.fileName].backgroundColor.push('#ff0000'); datasets[p.fileName].borderColor.push('#000000'); datasets[p.fileName].borderWidth.push(2); } else if (pointsInLastSectionIds.includes(p.id)) { datasets[p.fileName].pointRadius.push(6); datasets[p.fileName].backgroundColor.push('#c79fef'); datasets[p.fileName].borderColor.push('#5d3d7e'); datasets[p.fileName].borderWidth.push(1); } else { datasets[p.fileName].pointRadius.push(5); datasets[p.fileName].backgroundColor.push(loadedFiles[p.fileName]?.color + 'B3' || '#000000B3'); datasets[p.fileName].borderColor.push(loadedFiles[p.fileName]?.color || '#000'); datasets[p.fileName].borderWidth.push(1); } datasets[p.fileName].originalIndices.push(index); }); let finalDatasets = document.getElementById('toggleLineOnYzPlot').checked ? [...Object.values(datasets), ...Object.values(lineDatasets)] : Object.values(datasets); if(lastClusterResults) { const avgDataset = { type: 'scatter', label: 'å¹³å‡å€¤', data: lastClusterResults.map(r => ({x: r.meanY, y: r.meanEle})), pointStyle: 'circle', radius: 8, hoverRadius: 12, backgroundColor: lastClusterResults.map(r => r.color), borderColor: lastClusterResults.map(r => r.color), borderWidth: 2 }; finalDatasets.push(avgDataset); } if (yzChartInstance) { yzChartInstance.data.datasets = finalDatasets; yzChartInstance.update(); } else { yzChartInstance = new Chart(ctx, { data: { datasets: finalDatasets }, plugins: [yzPlotAspectRatioPlugin, scaleBarPlugin], options: { animation: false, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Yåº§æ¨™ (m)' } }, y: { title: { display: true, text: 'è£œæ­£å¾Œæ¨™é«˜ (m)' } } }, onHover: (event, elements) => highlightStatsTableRowOnHover(event, elements, yzChartInstance), plugins: { tooltip: { callbacks: { label: (ctx) => { if (ctx.dataset.label === 'å¹³å‡å€¤') return `${lastClusterResults[ctx.dataIndex].groupId}: (Y=${ctx.parsed.x.toFixed(4)}, Z=${ctx.parsed.y.toFixed(4)})`; const pointIndex = Object.values(datasets).find(ds => ds.label === ctx.dataset.label).originalIndices[ctx.dataIndex]; return `${activePoints[pointIndex].name}: (Y=${ctx.parsed.x.toFixed(3)}, Z=${ctx.parsed.y.toFixed(3)})`; }}}, zoom: { zoom: { wheel: { enabled: true }, mode: 'xy', onZoomStart: ({chart}) => { const t = document.getElementById('yzAspectRatioToggle'); wasYzAspectRatioChecked = t.checked; if(wasYzAspectRatioChecked) { t.checked = false; chart.update('none'); } }, onZoomComplete: ({chart}) => { if (wasYzAspectRatioChecked) { const t = document.getElementById('yzAspectRatioToggle'); t.checked = true; chart.update('none'); } wasYzAspectRatioChecked = false; } }, pan: { enabled: true, mode: 'xy' } } }, onClick: (evt) => { if (isSectionMode) return; if (yzChartInstance.isZoomedOrPanned() && evt.native.detail === 2) { yzChartInstance.resetZoom(); return; } const elems = yzChartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true).filter(e => yzChartInstance.data.datasets[e.datasetIndex].label !== 'å¹³å‡å€¤'); if (elems.length > 0) { const elem = elems[0]; const ds = yzChartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; focusOnPoint(null, activePoints[ptIdx].id); } }, } }); } }
        function addMarkersAndLine(points) { polylineLayer.clearLayers(); if (mapSectionLine) polylineLayer.addLayer(mapSectionLine); const allBounds = []; const pointsByFile = {}; points.forEach(p => { const popupContent = `<strong>${p.name}</strong><br>æ¨™é«˜: ${p.correctedEle.toFixed(3)}m<br><button class="action-button" onclick="togglePointVisibility('${p.id}')">ã“ã®ç‚¹ã‚’éè¡¨ç¤º</button>`; const marker = L.marker([p.lat, p.lon]).bindPopup(popupContent); polylineLayer.addLayer(marker); p.marker = marker; allBounds.push([p.lat, p.lon]); if (!pointsByFile[p.fileName]) pointsByFile[p.fileName] = []; pointsByFile[p.fileName].push(p); }); for (const f in pointsByFile) { if (pointsByFile[f].length > 1) { const latlngs = pointsByFile[f].map(p => [p.lat, p.lon]); polylineLayer.addLayer(L.polyline(latlngs, { color: loadedFiles[f]?.color || '#000', weight: 2 })); } } if (allBounds.length > 0 && !isSectionMode) map.fitBounds(allBounds, { padding: [50, 50] }); }
        
        function display3DPlot(points, highlightPointId) {
            const container = document.getElementById('plot-3d-container');
            if (points.length === 0) {
                Plotly.purge(container);
                container.innerHTML = '<div class="loading" style="text-align:center; padding-top: 50px;">è¡¨ç¤ºã™ã‚‹æ¸¬ç‚¹ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            const x_coords = points.map(p => p.y);
            const y_coords = points.map(p => p.x);
            const z_coords = points.map(p => p.correctedEle);
            const point_names = points.map(p => p.name);
            const point_colors = points.map(p => loadedFiles[p.fileName].color);
            const point_sizes = points.map(p => p.id === highlightPointId ? 8 : 4);

            const trace = {
                x: x_coords,
                y: y_coords,
                z: z_coords,
                mode: 'markers',
                type: 'scatter3d',
                text: point_names,
                hoverinfo: 'text+x+y+z',
                marker: {
                    color: point_colors,
                    size: point_sizes,
                    opacity: 0.8
                }
            };

const isAspectRatioOneToOne = document.getElementById('plot3dAspectRatioToggle').checked;

            const layout = {
                title: '3Dæ¸¬ç‚¹ãƒ—ãƒ­ãƒƒãƒˆ',
                scene: {
                    xaxis: { title: 'Yåº§æ¨™ (m)' },
                    yaxis: { title: 'Xåº§æ¨™ (m)' },
                    zaxis: { title: 'è£œæ­£å¾Œæ¨™é«˜ (m)' },
                    aspectmode: isAspectRatioOneToOne ? 'data' : 'manual',
                    aspectratio: isAspectRatioOneToOne ? null : {x: 1, y: 1, z: 0.5}
                },
                margin: { l: 0, r: 0, b: 0, t: 40 }
            };

            Plotly.newPlot(container, [trace], layout, {responsive: true});
        }
        
        window.focusOnPoint = (event, pointId) => { if (!pointId || (event && event.target.tagName.toLowerCase() === 'input')) return; if (window.getSelection().toString()) return; let masterPoint = null; for (const f in loadedFiles) { const p = loadedFiles[f].points.find(pt => pt.id === pointId); if (p) { masterPoint = p; break; } } if (!masterPoint) return; rerenderUI(pointId); if (!masterPoint.isHidden) { const point = activePoints.find(p => p.id === pointId); if (point?.marker) { point.marker.openPopup(); map.setView(point.marker.getLatLng(), 18); } } const row = document.querySelector(`tr[data-id="${pointId}"]`); if (row) { const tableContainer = document.getElementById('tableContainer'); const containerRect = tableContainer.getBoundingClientRect(); const rowRect = row.getBoundingClientRect(); if (rowRect.top < containerRect.top || rowRect.bottom > containerRect.bottom) { const desiredScrollTop = tableContainer.scrollTop + (rowRect.top - containerRect.top) - (containerRect.height / 2) + (rowRect.height / 2); tableContainer.scrollTo({ top: desiredScrollTop, behavior: 'auto' }); } } };
        function handleTableCellEdit(e) { const cell = e.target.closest('.editable-cell'); if (!cell || cell.querySelector('input')) return; const originalText = cell.querySelector('strong')?.textContent || cell.textContent; const field = cell.dataset.field; const pointId = cell.parentElement.dataset.id; cell.innerHTML = `<input type="text" value="${originalText.trim()}" />`; const input = cell.querySelector('input'); input.focus(); input.select(); const save = () => { let masterPoint = null; for(const f in loadedFiles){ const p = loadedFiles[f].points.find(pt => pt.id === pointId); if(p) { masterPoint = p; break; } } if (!masterPoint) return; const newValue = input.value; let changed = false; if (field === 'antennaHeight') { const num = parseFloat(newValue); if (!isNaN(num) && masterPoint.antennaHeight.toFixed(3) !== num.toFixed(3)) { masterPoint.antennaHeight = num; changed = true; } } else { if (masterPoint.name !== newValue) { masterPoint.name = newValue; changed = true; } } if (changed) { masterPoint.modifiedFields[field] = true; } updateUI(); rerenderUI(pointId); }; input.addEventListener('blur', save); input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') input.blur(); if (ev.key === 'Escape') { input.removeEventListener('blur', save); rerenderUI(pointId); } }); }
        function updateFileListUI() { const panel = document.getElementById('file-list-panel'); document.getElementById('file-list-panel-container').style.display = Object.keys(loadedFiles).length > 0 ? 'block' : 'none'; panel.innerHTML = ''; for (const f in loadedFiles) { const item = document.createElement('div'); item.className = 'file-item'; item.innerHTML = `<input type="checkbox" id="check-${f.replace(/[^a-zA-Z0-9]/g, '-')}" ${loadedFiles[f].visible?'checked':''}> <label for="check-${f.replace(/[^a-zA-Z0-9]/g, '-')}" title="${f}">${f}</label> <button class="delete-btn" title="å‰Šé™¤">&times;</button>`; panel.appendChild(item); item.querySelector('input').addEventListener('change', (e) => { loadedFiles[f].visible = e.target.checked; updateUI(); }); item.querySelector('button').addEventListener('click', () => { delete loadedFiles[f]; updateFileListUI(); updateUI(); }); } }
        function toggleSectionLineMode() { isSectionMode = !isSectionMode; const btn = document.getElementById('section-line-btn'); const status = document.getElementById('section-status'); const canvas = document.getElementById('xyPlot'); const createBtn = document.getElementById('create-section-profile-btn'); btn.classList.toggle('active', isSectionMode); sectionLineStart = null; isSectionLineDefined = false; lastDefinedSectionLinePoints = null; createBtn.disabled = true; canvas.classList.remove('crosshair', 'editable-section'); if (isSectionMode) { const mode = document.getElementById('section-mode-select').value; if (mode === 'coords') { document.getElementById('section-by-coords-modal').style.display = 'flex'; return; } const aspectRatioToggle = document.getElementById('aspectRatioToggle'); if (aspectRatioToggle.checked) { aspectRatioToggle.checked = false; aspectRatioToggle.dispatchEvent(new Event('change')); } status.style.display = 'inline'; canvas.classList.add('crosshair'); switch(mode) { case '2-point': status.textContent = 'ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ–­é¢ç·šã‚’è¨­å®š'; break; case 'vertical': status.textContent = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦é‰›ç›´ç·šã®ä½ç½®ã‚’æ±ºå®š'; break; case 'horizontal': status.textContent = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ°´å¹³ç·šã®ä½ç½®ã‚’æ±ºå®š'; break; } } else { status.style.display = 'none'; pointsInLastSectionIds = []; } rerenderUI(); }
        function getChartCoordsFromClick(e) { if (!chartInstance) return null; return { x: chartInstance.scales.x.getValueForPixel(e.x), y: chartInstance.scales.y.getValueForPixel(e.y) }; }
        function getChartCoordsFromCanvasEvent(e) { if (!chartInstance) return null; let clientX, clientY; const eventType = e.type; if (eventType.startsWith('touch')) { e.preventDefault(); const touch = (eventType === 'touchend' || eventType === 'touchcancel') ? e.changedTouches[0] : e.touches[0]; if (!touch) return null; clientX = touch.clientX; clientY = touch.clientY; } else { clientX = e.clientX; clientY = e.clientY; } const rect = e.target.getBoundingClientRect(); const offsetX = clientX - rect.left; const offsetY = clientY - rect.top; return { x: chartInstance.scales.x.getValueForPixel(offsetX), y: chartInstance.scales.y.getValueForPixel(offsetY) }; }
        function handlePlotDrawStart(e) { if (!isSectionMode || isSectionLineDefined || document.getElementById('section-mode-select').value !== '2-point') return; isDrawingSectionLine = true; sectionLineStart = getChartCoordsFromCanvasEvent(e); }
        function handlePlotDrawMove(e) { if (!sectionLineStart || !isDrawingSectionLine) return; const current = getChartCoordsFromCanvasEvent(e); if (current) { const annotations = chartInstance.options.plugins.annotation.annotations; if (!annotations.tempLine) { annotations.tempLine = { type: 'line', xMin: sectionLineStart.x, yMin: sectionLineStart.y, xMax: current.x, yMax: current.y, borderColor: 'rgba(255,0,0,0.5)', borderWidth: 2, drawTime: 'afterDraw' }; } else { annotations.tempLine.xMax = current.x; annotations.tempLine.yMax = current.y; } chartInstance.update('none'); } }
        function handlePlotDrawEnd(e) { if (!sectionLineStart || !isDrawingSectionLine) return; isDrawingSectionLine = false; const end = getChartCoordsFromCanvasEvent(e); delete chartInstance.options.plugins.annotation.annotations.tempLine; if (end) { if (Math.abs(sectionLineStart.x - end.x) > 1e-6 || Math.abs(sectionLineStart.y - end.y) > 1e-6) { defineSectionLineOnMapAndChart([sectionLineStart, end]); } } sectionLineStart = null; }
        function handlePlotClick(evt) { const elems = chartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true); if (isSectionMode) { if (isSectionLineDefined) { const scatterElems = elems.filter(e => chartInstance.data.datasets[e.datasetIndex].type === 'scatter'); if (scatterElems.length > 0) { const elem = scatterElems[0]; const ds = chartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; const pointId = activePoints[ptIdx].id; const indexInSelection = pointsInLastSectionIds.indexOf(pointId); if (indexInSelection > -1) { pointsInLastSectionIds.splice(indexInSelection, 1); } else { pointsInLastSectionIds.push(pointId); } document.getElementById('create-section-profile-btn').disabled = pointsInLastSectionIds.length < 2; updateSelectionHighlights(); } } else { const mode = document.getElementById('section-mode-select').value; const point = getChartCoordsFromClick(evt); if (!point) return; const { x: scaleX, y: scaleY } = chartInstance.scales; let linePoints = null; switch(mode) { case 'vertical': linePoints = [{x: point.x, y: scaleY.min}, {x: point.x, y: scaleY.max}]; break; case 'horizontal': linePoints = [{x: scaleX.min, y: point.y}, {x: scaleX.max, y: point.y}]; break; } if(linePoints) { defineSectionLineOnMapAndChart(linePoints); } } } else { const scatterElems = elems.filter(e => chartInstance.data.datasets[e.datasetIndex].type === 'scatter' && chartInstance.data.datasets[e.datasetIndex].label !== 'å¹³å‡å€¤'); if (scatterElems.length > 0) { const elem = scatterElems[0]; const ds = chartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; focusOnPoint(null, activePoints[ptIdx].id); } } }
        function updateSelectionHighlights() { document.querySelectorAll('#tableContainer tr[data-id]').forEach(row => { row.classList.toggle('in-section', pointsInLastSectionIds.includes(row.dataset.id)); }); const highlightPointId = document.querySelector('tr.highlighted')?.dataset.id; [chartInstance, xzChartInstance, yzChartInstance].forEach(instance => { if (!instance) return; instance.data.datasets.forEach(dataset => { if (dataset.type !== 'scatter' || dataset.label === 'å¹³å‡å€¤') return; dataset.originalIndices.forEach((originalIndex, dataIndex) => { const point = activePoints[originalIndex]; if (!point) return; if (point.id === highlightPointId) { dataset.pointRadius[dataIndex] = 10; dataset.backgroundColor[dataIndex] = '#ff0000'; dataset.borderColor[dataIndex] = '#000000'; dataset.borderWidth[dataIndex] = 2; } else if (pointsInLastSectionIds.includes(point.id)) { dataset.pointRadius[dataIndex] = 6; dataset.backgroundColor[dataIndex] = '#c79fef'; dataset.borderColor[dataIndex] = '#5d3d7e'; dataset.borderWidth[dataIndex] = 1; } else { dataset.pointRadius[dataIndex] = 5; dataset.backgroundColor[dataIndex] = loadedFiles[point.fileName].color + 'B3'; dataset.borderColor[dataIndex] = loadedFiles[point.fileName].color; dataset.borderWidth[dataIndex] = 1; } }); }); instance.update('none'); }); }
        function defineSectionLineOnMapAndChart(linePoints) { isSectionLineDefined = true; lastDefinedSectionLinePoints = linePoints; document.getElementById('xyPlot').classList.remove('crosshair'); document.getElementById('xyPlot').classList.add('editable-section'); const systemId = document.getElementById('coordSystem').value; const latLonLine = linePoints.map(p => xyToLatLon(p.y, p.x, systemId)); lastSectionCoords = { path: latLonLine, pathXY: linePoints }; if (mapSectionLine) map.removeLayer(mapSectionLine); const mapLineCoords = latLonLine.map(p => [p.lat, p.lon]); mapSectionLine = L.polyline(mapLineCoords, { color: 'red', weight: 3, dashArray: '5, 5' }).addTo(polylineLayer); document.getElementById('section-status').textContent = 'ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ–­é¢ã«å«ã‚ã‚‹æ¸¬ç‚¹ã‚’ç·¨é›†ã§ãã¾ã™'; const width = parseFloat(document.getElementById('section-width-input').value); if(isNaN(width) || width <= 0) return; pointsInLastSectionIds = []; activePoints.forEach(p => { const p_xy = latLonToXY(p.lat, p.lon, systemId); const pt = { x: p_xy.y, y: p_xy.x }; const closestInfo = findClosestPointOnPolyline(pt, lastDefinedSectionLinePoints); if (closestInfo.distance <= width / 2) { pointsInLastSectionIds.push(p.id); } }); document.getElementById('create-section-profile-btn').disabled = pointsInLastSectionIds.length < 2; rerenderUI(); }
        function updateSectionPlot(sectionType) { if (pointsInLastSectionIds.length < 2) { currentSectionData = []; } else if (sectionType === 'projected' && !lastDefinedSectionLinePoints) { currentSectionData = []; } else { const systemId = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); const sectionPoints = activePoints.filter(p => pointsInLastSectionIds.includes(p.id)); if (sectionType === 'projected') { currentSectionData = sectionPoints.map(p => { const p_xy = latLonToXY(p.lat, p.lon, systemId); const pt = { x: p_xy.y, y: p_xy.x }; const closestInfo = findClosestPointOnPolyline(pt, lastDefinedSectionLinePoints); return { x: closestInfo.distAlong, y: p.antennaHeight - pole, name: p.name, antennaHeight: p.antennaHeight, originalX: p_xy.x, originalY: p_xy.y }; }).sort((a, b) => a.x - b.x); } else { let cumulativeDistance = 0; currentSectionData = sectionPoints.map((p, i) => { const p_xy = latLonToXY(p.lat, p.lon, systemId); if (i > 0) { const prev_p = sectionPoints[i-1]; const prev_p_xy = latLonToXY(prev_p.lat, prev_p.lon, systemId); const dx = p_xy.x - prev_p_xy.x; const dy = p_xy.y - prev_p_xy.y; cumulativeDistance += Math.sqrt(dx*dx + dy*dy); } return { x: cumulativeDistance, y: p.antennaHeight - pole, name: p.name, antennaHeight: p.antennaHeight, originalX: p_xy.x, originalY: p_xy.y }; }); } } if (sectionChartInstance) { sectionChartInstance.data.datasets[0].data = currentSectionData; sectionChartInstance.update(); } }
        function generateAndShowSectionProfile() { if (pointsInLastSectionIds.length < 2) { alert("æ–­é¢ã«å«ã‚ã‚‹æ¸¬ç‚¹ãŒ2ã¤ä»¥ä¸Šé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; } if (!lastDefinedSectionLinePoints) { alert("æ–­é¢ç·šãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; } document.querySelector('#section-type-switch-container input[value="projected"]').checked = true; displaySectionProfileModal(); updateSectionPlot('projected'); }
        function findClosestPointOnPolyline(point, polyline) { let bestResult = { distance: Infinity, distAlong: 0 }; let accumulatedLength = 0; for (let i = 0; i < polyline.length - 1; i++) { const p1 = polyline[i]; const p2 = polyline[i+1]; const segLenSq = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2); let closest; let t = 0; if (segLenSq === 0) { closest = p1; } else { t = ((point.x - p1.x) * (p2.x - p1.x) + (point.y - p1.y) * (p2.y - p1.y)) / segLenSq; t = Math.max(0, Math.min(1, t)); closest = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) }; } const distSq = Math.pow(point.x - closest.x, 2) + Math.pow(point.y - closest.y, 2); if (distSq < bestResult.distance * bestResult.distance) { bestResult.distance = Math.sqrt(distSq); bestResult.distAlong = accumulatedLength + t * Math.sqrt(segLenSq); } accumulatedLength += Math.sqrt(segLenSq); } return bestResult; }
        const sectionPlotAspectRatioPlugin = { id: 'sectionPlotAspectRatio', afterDataLimits: (chart) => { if (!document.getElementById('sectionAspectRatioToggle').checked) { return; } const { x, y } = chart.scales; if (!x.width || !y.height) return; const xRange = x.max - x.min; const yRange = y.max - y.min; if (xRange <= 0 || yRange <= 0) return; const xPixelPerUnit = x.width / xRange; const yPixelPerUnit = y.height / yRange; if (xPixelPerUnit > yPixelPerUnit) { const newRange = x.width / yPixelPerUnit; const diff = newRange - xRange; x.min -= diff / 2; x.max += diff / 2; } else { const newRange = y.height / xPixelPerUnit; const diff = newRange - yRange; y.min -= diff / 2; y.max += diff / 2; } } };
        function displaySectionProfileModal() { const modal = document.getElementById('section-modal'); modal.style.display = 'flex'; const ctx = document.getElementById('sectionPlot'); if (sectionChartInstance) sectionChartInstance.destroy(); sectionChartInstance = new Chart(ctx, { type: 'line', data: { datasets: [{ label: 'æ–­é¢æ¨™é«˜', data: [], borderColor: '#3498db', tension: 0, pointBackgroundColor: '#3498db', showLine: true }] }, plugins: [sectionPlotAspectRatioPlugin], options: { maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'å§‹ç‚¹ã‹ã‚‰ã®è·é›¢ (m)' } }, y: { title: { display: true, text: 'è£œæ­£å¾Œæ¨™é«˜ (m)' } } }, plugins: { tooltip: { callbacks: { label: ctx => `${ctx.raw.name}: (è·é›¢ ${ctx.parsed.x.toFixed(3)}m, æ¨™é«˜ ${ctx.parsed.y.toFixed(3)}m)` } } } } }); setTimeout(() => sectionChartInstance.resize(), 100); }
        function toDxfUnicode(text) { let result = ''; for (let i = 0; i < text.length; i++) { const char = text[i]; const charCode = char.charCodeAt(0); if (charCode > 127) { result += `\\U+${charCode.toString(16).padStart(4, '0')}`; } else { result += char; } } return result; }
        function generateDxfHeaderAndTables(isCombined = false) { let dxf = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nTABLES\n`; dxf += `0\nTABLE\n2\nSTYLE\n70\n1\n0\nSTYLE\n2\nMSP-GOTHIC\n70\n0\n40\n0.0\n41\n1.0\n50\n0.0\n71\n0\n42\n0.25\n3\nMS Pã‚´ã‚·ãƒƒã‚¯\n4\n\n0\nENDTAB\n`; dxf += `0\nTABLE\n2\nLAYER\n70\n10\n`; const planLayers = [ {name: 'PLAN_POINTS', color: 1}, {name: 'PLAN_TEXT', color: 2}, {name: 'PLAN_LINES', color: 3}, {name: 'PLAN_SECTION_LINE', color: 1, linetype: 'DASHDOT'}, {name: 'PLAN_GRID_LINES', color: 8, linetype: 'DOTTED'}, {name: 'PLAN_GRID_TEXT', color: 8} ]; const sectionLayers = [ {name: 'SECTION_PROFILE', color: 4}, {name: 'SECTION_POINTS', color: 5}, {name: 'SECTION_TEXT', color: 6}, {name: 'SECTION_GRID_LINES', color: 8, linetype: 'DOTTED'}, {name: 'SECTION_GRID_TEXT', color: 8} ]; const layers = isCombined ? [...planLayers, ...sectionLayers] : (activePoints.length > 0 ? planLayers : sectionLayers); const uniqueLayers = layers.filter((layer, index, self) => index === self.findIndex((l) => l.name === layer.name)); uniqueLayers.forEach(l => { dxf += `0\nLAYER\n2\n${l.name}\n70\n0\n62\n${l.color}\n6\n${l.linetype || 'CONTINUOUS'}\n`; }); dxf += `0\nENDTAB\n0\nENDSEC\n`; return dxf; }
        function generateDxfEntities(points, gridInterval) { let dxf = ''; if (gridInterval > 0 && points.length > 0) { const minX = Math.min(...points.map(p=>p.y)), maxX = Math.max(...points.map(p=>p.y)); const minY = Math.min(...points.map(p=>p.x)), maxY = Math.max(...points.map(p=>p.x)); const startX = Math.floor(minX / gridInterval) * gridInterval, endX = Math.ceil(maxX / gridInterval) * gridInterval; const startY = Math.floor(minY / gridInterval) * gridInterval, endY = Math.ceil(maxY / gridInterval) * gridInterval; for (let x = startX; x <= endX; x += gridInterval) { dxf += `0\nLINE\n8\nPLAN_GRID_LINES\n10\n${x}\n20\n${minY}\n30\n0\n11\n${x}\n21\n${maxY}\n31\n0\n`; dxf += `0\nTEXT\n8\nPLAN_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${x}\n20\n${minY}\n30\n0\n40\n${gridInterval/10}\n1\n${x.toFixed(1)}\n`; } for (let y = startY; y <= endY; y += gridInterval) { dxf += `0\nLINE\n8\nPLAN_GRID_LINES\n10\n${minX}\n20\n${y}\n30\n0\n11\n${maxX}\n21\n${y}\n31\n0\n`; dxf += `0\nTEXT\n8\nPLAN_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${minX}\n20\n${y}\n30\n0\n40\n${gridInterval/10}\n1\n${y.toFixed(1)}\n`; } } points.forEach(p => { dxf += `0\nPOINT\n8\nPLAN_POINTS\n10\n${p.y.toFixed(4)}\n20\n${p.x.toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n`; dxf += `0\nTEXT\n8\nPLAN_TEXT\n7\nMSP-GOTHIC\n10\n${(p.y + 0.1).toFixed(4)}\n20\n${(p.x + 0.1).toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n40\n0.25\n1\n${toDxfUnicode(p.name)}\n`; }); const pointsByFile = {}; points.forEach(p => { if (!pointsByFile[p.fileName]) pointsByFile[p.fileName] = []; pointsByFile[p.fileName].push(p); }); for(const fileName in pointsByFile) { if(pointsByFile[fileName].length < 2) continue; dxf += `0\nPOLYLINE\n8\nPLAN_LINES\n66\n1\n70\n0\n`; pointsByFile[fileName].forEach(p => { dxf += `0\nVERTEX\n8\nPLAN_LINES\n10\n${p.y.toFixed(4)}\n20\n${p.x.toFixed(4)}\n30\n${p.correctedEle.toFixed(4)}\n`; }); dxf += `0\nSEQEND\n`; } if(lastSectionCoords && lastSectionCoords.pathXY.length > 1) { dxf += `0\nPOLYLINE\n8\nPLAN_SECTION_LINE\n66\n1\n70\n0\n`; lastSectionCoords.pathXY.forEach(p => { dxf += `0\nVERTEX\n8\nPLAN_SECTION_LINE\n10\n${p.x}\n20\n${p.y}\n30\n0\n`; }); dxf += `0\nSEQEND\n`; } return dxf; }
        function generateSectionDxfEntities(data, gridInterval, offsetX = 0, offsetY = 0) { let dxf = ''; if (gridInterval > 0 && data.length > 0) { const minX = 0, maxX = Math.max(...data.map(p=>p.x)); const minY = Math.min(...data.map(p=>p.y)), maxY = Math.max(...data.map(p=>p.y)); const startX = 0, endX = Math.ceil(maxX / gridInterval) * gridInterval; const startY = Math.floor(minY / gridInterval) * gridInterval, endY = Math.ceil(maxY / gridInterval) * gridInterval; for (let x = startX; x <= endX; x += gridInterval) { dxf += `0\nLINE\n8\nSECTION_GRID_LINES\n10\n${x+offsetX}\n20\n${minY+offsetY}\n30\n0\n11\n${x+offsetX}\n21\n${maxY+offsetY}\n31\n0\n`; dxf += `0\nTEXT\n8\nSECTION_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${x+offsetX}\n20\n${minY+offsetY}\n30\n0\n40\n${gridInterval/10}\n1\n${x.toFixed(1)}\n`; } for (let y = startY; y <= endY; y += gridInterval) { dxf += `0\nLINE\n8\nSECTION_GRID_LINES\n10\n${minX+offsetX}\n20\n${y+offsetY}\n30\n0\n11\n${maxX+offsetX}\n21\n${y+offsetY}\n31\n0\n`; dxf += `0\nTEXT\n8\nSECTION_GRID_TEXT\n7\nMSP-GOTHIC\n10\n${minX+offsetX}\n20\n${y+offsetY}\n30\n0\n40\n${gridInterval/10}\n1\n${y.toFixed(1)}\n`; } } dxf += `0\nPOLYLINE\n8\nSECTION_PROFILE\n66\n1\n70\n0\n`; data.forEach(p => { dxf += `0\nVERTEX\n8\nSECTION_PROFILE\n10\n${(p.x + offsetX).toFixed(4)}\n20\n${(p.y + offsetY).toFixed(4)}\n30\n0\n`; }); dxf += `0\nSEQEND\n`; data.forEach(p => { dxf += `0\nPOINT\n8\nSECTION_POINTS\n10\n${(p.x + offsetX).toFixed(4)}\n20\n${(p.y + offsetY).toFixed(4)}\n30\n0\n`; dxf += `0\nTEXT\n8\nSECTION_TEXT\n7\nMSP-GOTHIC\n10\n${(p.x + 0.1 + offsetX).toFixed(4)}\n20\n${(p.y + 0.1 + offsetY).toFixed(4)}\n30\n0\n40\n0.25\n1\n${toDxfUnicode(p.name)}\n`; const coordText = `(Y=${p.originalY.toFixed(3)},X=${p.originalX.toFixed(3)})`; dxf += `0\nTEXT\n8\nSECTION_TEXT\n7\nMSP-GOTHIC\n10\n${(p.x + 0.1 + offsetX).toFixed(4)}\n20\n${(p.y - 0.3 + offsetY).toFixed(4)}\n30\n0\n40\n0.15\n1\n${toDxfUnicode(coordText)}\n`; }); return dxf; }
        function generateCombinedDxfContent(gridIntervalPlan, gridIntervalSection) { const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole })); if (processedPoints.length === 0) { alert("å¹³é¢å›³ã«å‡ºåŠ›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return ''; } let dxf = generateDxfHeaderAndTables(true); dxf += `0\nSECTION\n2\nENTITIES\n`; dxf += generateDxfEntities(processedPoints, gridIntervalPlan); dxf += generateSectionDxfEntities(currentSectionData, gridIntervalSection, 0, 0); dxf += `0\nENDSEC\n0\nEOF\n`; return dxf; }
        function saveProject() { if (Object.keys(loadedFiles).length === 0) { alert("ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return; } const projectData = { version: "3.2", savedAt: new Date().toISOString(), loadedFiles: {}, pointOrder: activePoints.map(p => p.id), uiState: { coordSystem: document.getElementById('coordSystem').value, poleHeight: document.getElementById('poleHeight').value, mapView: { center: map.getCenter(), zoom: map.getZoom() }, lastSectionCoords: lastSectionCoords, activeTabId: document.querySelector('.tab-button.active').id } }; for (const fileName in loadedFiles) { const fileData = loadedFiles[fileName]; const savedFile = { gpxContent: fileData.gpxContent, visible: fileData.visible, color: fileData.color, modifications: {}, pointsData: [] }; fileData.points.forEach(p => { savedFile.pointsData.push({ id: p.id, name: p.name, lat: p.lat, lon: p.lon, antennaHeight: p.antennaHeight, time: p.time, cmtText: p.cmtText, pointGeoidHeight: p.pointGeoidHeight, ellipsoidHeight: p.ellipsoidHeight, eleDiff: p.eleDiff, isHidden: p.isHidden }); if (Object.keys(p.modifiedFields).length > 0) { savedFile.modifications[p.id] = {}; if (p.modifiedFields.name) savedFile.modifications[p.id].name = p.name; if (p.modifiedFields.antennaHeight) savedFile.modifications[p.id].antennaHeight = p.antennaHeight; } }); projectData.loadedFiles[fileName] = savedFile; } const jsonString = JSON.stringify(projectData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `gnss-viewer-project.gsv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
        function loadProject(file) { if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const projectData = JSON.parse(e.target.result); if (!projectData.version || !projectData.loadedFiles) { throw new Error("ç„¡åŠ¹ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚"); } loadedFiles = {}; activePoints = []; lastSectionCoords = null; actionHistory = []; document.getElementById('undoBtn').disabled = true; if (chartInstance) { chartInstance.destroy(); chartInstance = null; } if (xzChartInstance) { xzChartInstance.destroy(); xzChartInstance = null; } if (yzChartInstance) { yzChartInstance.destroy(); yzChartInstance = null; } Plotly.purge('plot-3d-container'); for (const fileName in projectData.loadedFiles) { const fileData = projectData.loadedFiles[fileName]; let points = []; if (fileData.pointsData) { points = fileData.pointsData.map(p => ({ ...p, fileName: fileName, modifiedFields: {}, isHidden: p.isHidden || false })); } else { console.warn(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã® ${fileName} ã«ã¯è¡¨ç¤ºã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`); continue; } if (fileData.modifications) { points.forEach(p => { if (fileData.modifications[p.id]) { const mod = fileData.modifications[p.id]; if (mod.name) { p.name = mod.name; p.modifiedFields.name = true; } if (mod.antennaHeight !== undefined) { p.antennaHeight = mod.antennaHeight; p.modifiedFields.antennaHeight = true; } } }); } loadedFiles[fileName] = { points: points, visible: fileData.visible, color: fileData.color, gpxContent: fileData.gpxContent }; } const ui = projectData.uiState; document.getElementById('coordSystem').value = ui.coordSystem; document.getElementById('poleHeight').value = ui.poleHeight; map.setView(ui.mapView.center, ui.mapView.zoom); lastSectionCoords = ui.lastSectionCoords; updateFileListUI(); updateUI(); } catch (err) { alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${err.message}`); } finally { document.getElementById('projectInput').value = ''; } }; reader.readAsText(file); }
        function performClusteringAndStatistics(xyToleranceCm, zToleranceCm) { if (activePoints.length === 0) { alert("å‡¦ç†å¯¾è±¡ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return; } const xyTolerance = xyToleranceCm / 100.0; const zTolerance = zToleranceCm / 100.0; const sys = document.getElementById('coordSystem').value; const pole = parseFloat(document.getElementById('poleHeight').value); const allCurrentPoints = []; for(const f in loadedFiles) { allCurrentPoints.push(...loadedFiles[f].points.filter(p => !p.isHidden)); } const processedPoints = allCurrentPoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole, processed: false })); const groups = []; lastClusteredPointIds.clear(); for (let i = 0; i < processedPoints.length; i++) { const point = processedPoints[i]; if (point.processed) continue; const newGroup = []; const queue = [point]; point.processed = true; while (queue.length > 0) { const current = queue.shift(); newGroup.push(current); for (let j = 0; j < processedPoints.length; j++) { const other = processedPoints[j]; if (other.processed) continue; const dx = current.x - other.x; const dy = current.y - other.y; const dz = current.correctedEle - other.correctedEle; const distXY = Math.sqrt(dx * dx + dy * dy); const distZ = Math.abs(dz); if (distXY <= xyTolerance && distZ <= zTolerance) { other.processed = true; queue.push(other); } } } if (newGroup.length > 1) { groups.push(newGroup); newGroup.forEach(p => lastClusteredPointIds.add(p.id)); } } if (groups.length === 0) { alert("è¨­å®šã•ã‚ŒãŸé–¾å€¤å†…ã§ã€è¤‡æ•°ã®æ¸¬å®šè¨˜éŒ²ãŒã‚ã‚‹åœ°ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚é–¾å€¤ã‚’åºƒã’ã¦è©¦ã—ã¦ãã ã•ã„ã€‚"); return; } lastClusterResults = groups.map((group, index) => { const xCoords = group.map(p => p.x); const yCoords = group.map(p => p.y); const eleCoords = group.map(p => p.correctedEle); const meanX = getMean(xCoords); const meanY = getMean(yCoords); const meanEle = getMean(eleCoords); const commonName = findLongestCommonPrefix(group.map(p => p.name)); return { groupId: commonName || `ã‚°ãƒ«ãƒ¼ãƒ— ${index + 1}`, originalPointIds: group.map(p => p.id), points: group.map(p => p.name), count: group.length, meanX: meanX, meanY: meanY, meanEle: meanEle, stdDevX: getStdDev(xCoords, meanX), stdDevY: getStdDev(yCoords, meanY), stdDevEle: getStdDev(eleCoords, meanEle), rangeX: Math.max(...xCoords) - Math.min(...xCoords), rangeY: Math.max(...yCoords) - Math.min(...yCoords), color: COLORS[index % COLORS.length] }; }); displayGroupStatisticsModal(lastClusterResults); displayGroupStatsOnMap(lastClusterResults, sys); rerenderUI(); }
        function displayGroupStatisticsModal(results) { const modal = document.getElementById('stats-modal'); const body = document.getElementById('stats-modal-body'); let tableHTML = `<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;"><thead><tr style="background-color: #2c3e50; color: white;"><th style="padding: 8px; border: 1px solid #ddd;">ã‚°ãƒ«ãƒ¼ãƒ—ID</th><th style="padding: 8px; border: 1px solid #ddd;">å›æ•°</th><th style="padding: 8px; border: 1px solid #ddd;">å¹³å‡X (m)</th><th style="padding: 8px; border: 1px solid #ddd;">å¹³å‡Y (m)</th><th style="padding: 8px; border: 1px solid #ddd;">å¹³å‡æ¨™é«˜ (m)</th><th style="padding: 8px; border: 1px solid #ddd;" title="Xåº§æ¨™ã®æ¨™æº–åå·®">ÏƒX (m)</th><th style="padding: 8px; border: 1px solid #ddd;" title="Yåº§æ¨™ã®æ¨™æº–åå·®">ÏƒY (m)</th><th style="padding: 8px; border: 1px solid #ddd;" title="æ¨™é«˜ã®æ¨™æº–åå·®">Ïƒæ¨™é«˜ (m)</th><th style="padding: 8px; border: 1px solid #ddd;" title="æ°´å¹³æ–¹å‘ã®æœ€å¤§æœ€å°ã®å·®">ç¯„å›²XY (m)</th></tr></thead><tbody>`; results.forEach((r, index) => { const horizontalRange = Math.sqrt(r.rangeX**2 + r.rangeY**2); const originalNames = r.points.join(', '); tableHTML += `<tr data-group-index="${index}"><td style="padding: 8px; border: 1px solid #ddd; cursor: help;" title="å«ã¾ã‚Œã‚‹æ¸¬ç‚¹: ${originalNames}"><span class="color-indicator" style="background-color:${r.color};"></span>${r.groupId}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.count}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.meanX.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.meanY.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.meanEle.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.stdDevX.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.stdDevY.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${r.stdDevEle.toFixed(4)}</td><td style="padding: 8px; border: 1px solid #ddd;">${horizontalRange.toFixed(4)}</td></tr>`; }); tableHTML += `</tbody></table>`; body.innerHTML = tableHTML; modal.style.display = 'flex'; }
        function displayGroupStatsOnMap(results, systemId) { if (statsLayerGroup) { statsLayerGroup.clearLayers(); } else { statsLayerGroup = L.layerGroup().addTo(map); } results.forEach(r => { const { lat, lon } = xyToLatLon(r.meanX, r.meanY, systemId); const horizontalStdDev = Math.sqrt(r.stdDevX**2 + r.stdDevY**2); const iconHtml = `<span style="font-size: 24px; color: ${r.color}; text-shadow: -1px 0 #000, 0 1px #000, 1px 0 #000, 0 -1px #000;">â˜…</span>`; const avgMarker = L.marker([lat, lon], { icon: L.divIcon({ html: iconHtml, className: 'text-marker', iconSize: [24, 24], iconAnchor: [12, 12] }) }).bindPopup(`<b>${r.groupId} (å¹³å‡å€¤)</b><br>æ¸¬å®šå›æ•°: ${r.count}<br>æ°´å¹³æ¨™æº–åå·® (ÏƒXY): ${horizontalStdDev.toFixed(4)}m`); statsLayerGroup.addLayer(avgMarker); if (horizontalStdDev > 0) { const circle = L.circle([lat, lon], { radius: horizontalStdDev, color: r.color, fillColor: r.color, fillOpacity: 0.3 }); statsLayerGroup.addLayer(circle); } }); }
        function addAveragesToData() { if (!lastClusterResults) { alert("çµ±è¨ˆå‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; } const sys = document.getElementById('coordSystem').value; const avgFileName = "çµ±è¨ˆå‡¦ç†_å¹³å‡å€¤"; const ungroupedFileName = "çµ±è¨ˆå‡¦ç†_å¯¾è±¡å¤–ãƒ‡ãƒ¼ã‚¿"; const newAvgPoints = lastClusterResults.map((r, index) => { const { lat, lon } = xyToLatLon(r.meanX, r.meanY, sys); return { id: `${avgFileName}-${index}`, name: `${r.groupId} (å¹³å‡)`, lat: lat, lon: lon, antennaHeight: r.meanEle, time: new Date().toISOString(), cmtText: `(${r.count}ç‚¹ã®å¹³å‡å€¤)`, fileName: avgFileName, modifiedFields: {}, isHidden: false }; }); let allOriginalPoints = []; for(const f in loadedFiles) { allOriginalPoints.push(...loadedFiles[f].points.filter(p => !p.isHidden)); } const newUngroupedPoints = allOriginalPoints.filter(p => !lastClusteredPointIds.has(p.id)).map(p => ({ ...p, fileName: ungroupedFileName, id: `${ungroupedFileName}-${p.id}` })); if (loadedFiles[avgFileName] || loadedFiles[ungroupedFileName]) { if(!confirm(`çµ±è¨ˆå‡¦ç†ãƒ‡ãƒ¼ã‚¿ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ`)) return; } loadedFiles[avgFileName] = { points: newAvgPoints, visible: true, color: '#ff00ff', gpxContent: null }; if(newUngroupedPoints.length > 0) { loadedFiles[ungroupedFileName] = { points: newUngroupedPoints, visible: true, color: '#888888', gpxContent: null }; } Object.keys(loadedFiles).forEach(fileName => { if (fileName !== avgFileName && fileName !== ungroupedFileName) { loadedFiles[fileName].visible = false; } }); alert(`ã€Œ${avgFileName}ã€ã¨ã€Œ${ungroupedFileName}ã€ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚\nå…ƒã®ãƒ‡ãƒ¼ã‚¿ã¯éè¡¨ç¤ºã«ãªã£ã¦ã„ã¾ã™ã€‚`); updateFileListUI(); updateUI(); document.getElementById('stats-modal').style.display = 'none'; if (statsLayerGroup) statsLayerGroup.clearLayers(); lastClusterResults = null; rerenderUI(); }
        
        function initialize() {
            coordinateSystems.forEach(sys => { const projDef = `+proj=tmerc +lat_0=${sys.lat0} +lon_0=${sys.lon0} +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs`; proj4.defs(`EPSG:${sys.epsg}`, projDef); });
            for (let i = 1; i <= 19; i++) { const opt = document.createElement('option'); opt.value = i; opt.textContent = `ç¬¬${i}ç³»`; if (i === 9) opt.selected = true; document.getElementById('coordSystem').appendChild(opt); }
            initMap();
            document.getElementById('fileInput').addEventListener('change', (e) => processFiles(e.target.files));
            document.getElementById('csvInput').addEventListener('change', (e) => processFiles(e.target.files));
            document.getElementById('coordSystem').addEventListener('change', () => rerenderUI());
            document.getElementById('undoBtn').addEventListener('click', undoLastAction);
            
            const poleHeightInput = document.getElementById('poleHeight');
            const poleHeightPreset = document.getElementById('poleHeightPreset');
            poleHeightInput.addEventListener('input', () => { rerenderUI(); const currentValue = poleHeightInput.value; let matchFound = false; for (const option of poleHeightPreset.options) { if (option.value !== "" && parseFloat(option.value) === parseFloat(currentValue)) { poleHeightPreset.value = option.value; matchFound = true; break; } } if (!matchFound) { poleHeightPreset.value = ""; } });
            poleHeightPreset.addEventListener('change', (e) => { const presetValue = e.target.value; if (presetValue !== "") { poleHeightInput.value = presetValue; poleHeightInput.dispatchEvent(new Event('input', { bubbles: true })); } });

            document.getElementById('toggleLineOnPlot').addEventListener('change', () => rerenderUI());
            document.getElementById('toggleLineOnXzPlot').addEventListener('change', () => rerenderUI());
            document.getElementById('toggleLineOnYzPlot').addEventListener('change', () => rerenderUI());
            document.getElementById('aspectRatioToggle').addEventListener('change', () => { if (chartInstance) chartInstance.update(); });
            document.getElementById('xzAspectRatioToggle').addEventListener('change', () => { if (xzChartInstance) xzChartInstance.update(); });
            document.getElementById('yzAspectRatioToggle').addEventListener('change', () => { if (yzChartInstance) yzChartInstance.update(); });
            document.getElementById('plot3dAspectRatioToggle').addEventListener('change', () => rerenderUI());
            const tableContainer = document.getElementById('tableContainer'); 
            tableContainer.addEventListener('click', (e) => { const targetRow = e.target.closest('tr'); if (!targetRow) return; if (e.target.classList.contains('visibility-toggle')) return; if (targetRow.classList.contains('highlighted') && e.target.closest('.editable-cell')) return; if (window.getSelection().toString()) return; focusOnPoint(e, targetRow.dataset.id); });
            tableContainer.addEventListener('dblclick', handleTableCellEdit);
            const mobileTabs = document.querySelector('.mobile-only-tabs'); const desktopTabs = document.querySelector('.right-panel .tab-bar'); const leftPanel = document.querySelector('.left-panel'); const rightPanel = document.querySelector('.right-panel');
            mobileTabs.addEventListener('click', (e) => { if (!e.target.classList.contains('tab-button')) return; mobileTabs.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); const targetId = e.target.id; if (targetId === 'tab-data-mobile') { leftPanel.classList.remove('hidden-on-mobile'); rightPanel.classList.add('hidden-on-mobile'); } else { leftPanel.classList.add('hidden-on-mobile'); rightPanel.classList.remove('hidden-on-mobile'); if (targetId === 'tab-map-mobile') { document.getElementById('tab-map').click(); } else if (targetId === 'tab-plot-mobile') { document.getElementById('tab-plot').click();                     } else if (targetId === 'tab-xz-plot-mobile') { // â–¼ã“ã“ã‹ã‚‰è¿½åŠ 
                        document.getElementById('tab-xz-plot').click();
                    } else if (targetId === 'tab-yz-plot-mobile') {
                        document.getElementById('tab-yz-plot').click(); // â–²ã“ã“ã¾ã§è¿½åŠ 
                    } else if (targetId === 'tab-3d-plot-mobile') {
                        document.getElementById('tab-3d-plot').click();
                    }
                }
            });
            desktopTabs.addEventListener('click', (e) => { if (!e.target.classList.contains('tab-button')) return; desktopTabs.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active')); document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active')); e.target.classList.add('active'); const paneId = e.target.id.replace('tab-', 'pane-'); document.getElementById(paneId).classList.add('active'); if (paneId === 'pane-map') { setTimeout(() => map.invalidateSize(), 10); } else if (paneId === 'pane-plot' && chartInstance) { setTimeout(() => chartInstance.resize(), 10); } else if (paneId === 'pane-xz-plot' && xzChartInstance) { setTimeout(() => xzChartInstance.resize(), 10); } else if (paneId === 'pane-yz-plot' && yzChartInstance) { setTimeout(() => yzChartInstance.resize(), 10); } else if (paneId === 'pane-3d-plot') { setTimeout(() => Plotly.Plots.resize(document.getElementById('plot-3d-container')), 10); } });
            const body = document.body; body.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('drag-over'); }); body.addEventListener('dragleave', () => body.classList.remove('drag-over')); body.addEventListener('drop', (e) => { e.preventDefault(); body.classList.remove('drag-over'); processFiles(e.dataTransfer.files); });
            document.getElementById('section-line-btn').addEventListener('click', toggleSectionLineMode);
            document.getElementById('create-section-profile-btn').addEventListener('click', generateAndShowSectionProfile);
            document.getElementById('sectionAspectRatioToggle').addEventListener('change', () => { if (sectionChartInstance) sectionChartInstance.update(); });
            const plotCanvas = document.getElementById('xyPlot');
            plotCanvas.addEventListener('mousedown', handlePlotDrawStart); plotCanvas.addEventListener('mousemove', handlePlotDrawMove); plotCanvas.addEventListener('mouseup', handlePlotDrawEnd);
            plotCanvas.addEventListener('touchstart', handlePlotDrawStart, { passive: false }); plotCanvas.addEventListener('touchmove', handlePlotDrawMove, { passive: false }); plotCanvas.addEventListener('touchend', handlePlotDrawEnd);
            
            const plotContextMenu = document.getElementById('plot-context-menu');
            plotCanvas.addEventListener('contextmenu', e => { e.preventDefault(); const elems = chartInstance.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true); const scatterElems = elems.filter(el => chartInstance.data.datasets[el.datasetIndex].type === 'scatter' && chartInstance.data.datasets[el.datasetIndex].label !== 'å¹³å‡å€¤'); if(scatterElems.length > 0) { const elem = scatterElems[0]; const ds = chartInstance.data.datasets[elem.datasetIndex]; const ptIdx = ds.originalIndices[elem.index]; contextMenuPointId = activePoints[ptIdx].id; plotContextMenu.style.display = 'block'; plotContextMenu.style.left = `${e.clientX}px`; plotContextMenu.style.top = `${e.clientY}px`; } });
            document.getElementById('hide-point-from-plot-btn').addEventListener('click', () => { if(contextMenuPointId) togglePointVisibility(contextMenuPointId); plotContextMenu.style.display = 'none'; });
            document.addEventListener('click', () => { plotContextMenu.style.display = 'none'; });
            
            const sectionModal = document.getElementById('section-modal');
            sectionModal.addEventListener('click', (e) => { if (e.target === sectionModal || e.target.classList.contains('modal-close')) sectionModal.style.display = 'none'; });
            window.addEventListener('resize', () => { setTimeout(() => { if(map) map.invalidateSize(); if(chartInstance) chartInstance.resize(); if(xzChartInstance) xzChartInstance.resize(); if(yzChartInstance) yzChartInstance.resize(); if(sectionChartInstance) sectionChartInstance.resize(); if (document.getElementById('pane-3d-plot').classList.contains('active')) Plotly.Plots.resize(document.getElementById('plot-3d-container')); }, 100); });
            document.getElementById('projectSaveBtnHeader').addEventListener('click', saveProject);
            document.getElementById('projectLoadBtnHeader').addEventListener('click', () => document.getElementById('projectInput').click());
            document.getElementById('projectInput').addEventListener('change', (e) => loadProject(e.target.files[0]));
            document.getElementById('legal-toggle').addEventListener('click', () => { const details = document.getElementById('legal-details'); const toggle = document.getElementById('legal-toggle'); const isHidden = details.style.display === 'none'; details.style.display = isHidden ? 'block' : 'none'; toggle.textContent = isHidden ? 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§éè¡¨ç¤º)' : 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)'; });
            const coordModal = document.getElementById('coord-modal');
            document.getElementById('coord-modal-ok').addEventListener('click', () => { const selectedSystemId = document.getElementById('modal-coord-system').value; try { const points = processCsvPoints(tempCsvContent, tempCsvFileName, selectedSystemId); if(points.length === 0) { alert(`ãƒ‡ãƒ¼ã‚¿ã€Œ${tempCsvFileName}ã€ã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); } else { loadedFiles[tempCsvFileName] = { points, visible: true, color: COLORS[Object.keys(loadedFiles).length % COLORS.length], gpxContent: null }; updateFileListUI(); updateUI(); } } catch (err) { alert(`ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼ (${tempCsvFileName}): ${err.message}`); } finally { coordModal.style.display = 'none'; tempCsvContent = null; tempCsvFileName = null; } });
            document.getElementById('coord-modal-cancel').addEventListener('click', () => { coordModal.style.display = 'none'; tempCsvContent = null; tempCsvFileName = null; });
            const textImportModal = document.getElementById('text-import-modal');
            document.getElementById('textImportBtn').addEventListener('click', () => { textImportModal.style.display = 'flex'; document.getElementById('text-import-textarea').value = ''; });
            textImportModal.querySelector('.modal-close').addEventListener('click', () => textImportModal.style.display = 'none');
            document.getElementById('text-import-cancel').addEventListener('click', () => textImportModal.style.display = 'none');
            document.getElementById('text-import-ok').addEventListener('click', () => { const textContent = document.getElementById('text-import-textarea').value; if (textContent.trim() === '') { alert('ãƒ†ã‚­ã‚¹ãƒˆãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); return; } const fileName = `Pasted_Data_${textImportCounter++}`; try { const points = parseCSV(textContent, fileName); if (points === null) {} else if(points.length === 0) { alert(`è²¼ã‚Šä»˜ã‘ã‚‰ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æœ‰åŠ¹ãªæ¸¬ç‚¹ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚`); } else { loadedFiles[fileName] = { points, visible: true, color: COLORS[Object.keys(loadedFiles).length % COLORS.length], gpxContent: null }; updateFileListUI(); updateUI(); } } catch (err) { alert(`ãƒ†ã‚­ã‚¹ãƒˆè§£æã‚¨ãƒ©ãƒ¼: ${err.message}`); } textImportModal.style.display = 'none'; });
            document.querySelectorAll('#section-type-switch-container input[name="sectionType"]').forEach(radio => { radio.addEventListener('change', (e) => updateSectionPlot(e.target.value)); });
            const today = new Date();
            document.getElementById('lastUpdated').textContent = `æœ€çµ‚æ›´æ–°æ—¥: ${today.getFullYear()}å¹´${today.getMonth() + 1}æœˆ${today.getDate()}æ—¥`;
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('help-modal');
            helpBtn.addEventListener('click', () => { helpModal.style.display = 'flex'; });
            helpModal.addEventListener('click', (e) => { if (e.target === helpModal || e.target.classList.contains('modal-close')) { helpModal.style.display = 'none'; } });
            
            const clusterSettingsModal = document.getElementById('cluster-settings-modal');
            const statsModal = document.getElementById('stats-modal');
            document.getElementById('clusterStatsBtn').addEventListener('click', () => { if(Object.keys(loadedFiles).length === 0) { alert("å‡¦ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return; } clusterSettingsModal.style.display = 'flex'; });
            clusterSettingsModal.querySelector('.modal-close').addEventListener('click', () => { clusterSettingsModal.style.display = 'none'; });
            document.getElementById('cluster-settings-cancel').addEventListener('click', () => { clusterSettingsModal.style.display = 'none'; });
            document.getElementById('cluster-settings-ok').addEventListener('click', () => { const xyTolerance = parseFloat(document.getElementById('xy-tolerance').value); const zTolerance = parseFloat(document.getElementById('z-tolerance').value); if (isNaN(xyTolerance) || isNaN(zTolerance) || xyTolerance < 0 || zTolerance < 0) { alert("æœ‰åŠ¹ãªæ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"); return; } clusterSettingsModal.style.display = 'none'; performClusteringAndStatistics(xyTolerance, zTolerance); });
            statsModal.querySelector('.modal-close').addEventListener('click', () => { statsModal.style.display = 'none'; if (statsLayerGroup) statsLayerGroup.clearLayers(); lastClusterResults = null; rerenderUI(); });
            document.getElementById('addAveragesBtn').addEventListener('click', addAveragesToData);
            document.getElementById('downloadStatsCsvBtn').addEventListener('click', () => { if (!lastClusterResults) { alert("ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return; } let csv = "\uFEFF"; csv += "ã‚°ãƒ«ãƒ¼ãƒ—ID,å›æ•°,å¹³å‡X(m),å¹³å‡Y(m),å¹³å‡æ¨™é«˜(m),æ¨™æº–åå·®X(m),æ¨™æº–åå·®Y(m),æ¨™æº–åå·®æ¨™é«˜(m),å«ã¾ã‚Œã‚‹æ¸¬ç‚¹å\r\n"; lastClusterResults.forEach(r => { const names = `"${r.points.join(', ')}"`; csv += [r.groupId, r.count, r.meanX.toFixed(4), r.meanY.toFixed(4), r.meanEle.toFixed(4), r.stdDevX.toFixed(4), r.stdDevY.toFixed(4), r.stdDevEle.toFixed(4), names].join(',') + '\r\n'; }); const link = document.createElement("a"); link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv); link.download = 'cluster_statistics.csv'; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
            
            let isDragging = false; let offsetX, offsetY;
            const statsHeader = statsModal.querySelector('.modal-header');
            statsHeader.addEventListener('mousedown', (e) => { if(e.target.tagName === 'BUTTON') return; isDragging = true; offsetX = e.clientX - statsModal.offsetLeft; offsetY = e.clientY - statsModal.offsetTop; statsModal.style.userSelect = 'none'; });
            document.addEventListener('mousemove', (e) => { if (isDragging) { statsModal.style.left = `${e.clientX - offsetX}px`; statsModal.style.top = `${e.clientY - offsetY}px`; } });
            document.addEventListener('mouseup', () => { isDragging = false; statsModal.style.userSelect = ''; });

            const sectionCoordsModal = document.getElementById('section-by-coords-modal');
            sectionCoordsModal.querySelector('.modal-close').addEventListener('click', () => sectionCoordsModal.style.display = 'none');
            document.getElementById('section-coords-cancel').addEventListener('click', () => sectionCoordsModal.style.display = 'none');
            document.getElementById('section-coords-ok').addEventListener('click', () => {
                const startY = parseFloat(document.getElementById('section-start-y').value);
                const startX = parseFloat(document.getElementById('section-start-x').value);
                const endY = parseFloat(document.getElementById('section-end-y').value);
                const endX = parseFloat(document.getElementById('section-end-x').value);
                if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
                    alert('æœ‰åŠ¹ãªåº§æ¨™ã‚’4ã¤ã™ã¹ã¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚'); return;
                }
                const linePoints = [{ x: startY, y: startX }, { x: endY, y: endX }];
                defineSectionLineOnMapAndChart(linePoints);
                sectionCoordsModal.style.display = 'none';
            });
// --- ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã€æ—¢å­˜ã®CSV/DXFãƒœã‚¿ãƒ³ã®ã‚³ãƒ¼ãƒ‰ã‚’ç½®ãæ›ãˆã¦ãã ã•ã„ ---

            // ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: CSVä¿å­˜ãƒœã‚¿ãƒ³ (ä¿®æ­£ç‰ˆ)
            document.getElementById('downloadCsvBtn').addEventListener('click', () => {
                if (activePoints.length === 0) {
                    alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                    return;
                }

                // CSVãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
                const escapeCsvField = (field) => {
                    if (field === null || typeof field === 'undefined') {
                        return '';
                    }
                    const str = String(field);
                    if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
                        // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’2ã¤ã«ç½®ãæ›ãˆã€å…¨ä½“ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã‚€
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return str;
                };

                const sys = document.getElementById('coordSystem').value;
                const pole = parseFloat(document.getElementById('poleHeight').value);
                let csvContent = "\uFEFF"; // Excelç”¨ã®BOM
                
                // æ–°ã—ã„ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
                const headers = [
                    "æ¸¬ç‚¹å", "ç·¯åº¦", "çµŒåº¦", "X(m)", "Y(m)", 
                    "ã‚¢ãƒ³ãƒ†ãƒŠé«˜(m)", "è£œæ­£å¾Œæ¨™é«˜(m)", "CMTãƒ‡ãƒ¼ã‚¿", "ã‚¸ã‚ªã‚¤ãƒ‰é«˜", 
                    "ã‚¸ã‚ªã‚¤ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ", "FIXãƒ¢ãƒ¼ãƒ‰"
                ];
                csvContent += headers.join(',') + "\r\n";

                activePoints.forEach(p => {
                    const coords = latLonToXY(p.lat, p.lon, sys);
                    const correctedEle = p.antennaHeight - pole;
                    
                    let rowData = [
                        p.name, p.lat.toFixed(9), p.lon.toFixed(9), 
                        coords.x.toFixed(4), coords.y.toFixed(4), 
                        p.antennaHeight.toFixed(4), correctedEle.toFixed(4)
                    ];

                    // çµ±è¨ˆå‡¦ç†ã§ä½œæˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®å ´åˆã€è¿½åŠ æƒ…å ±ã¯ç©ºã«ã™ã‚‹
                    if (p.fileName && p.fileName.startsWith("çµ±è¨ˆå‡¦ç†_")) {
                        rowData.push('', '', '', '');
                    } else {
                        rowData.push(
                            p.cmtText || '',
                            p.pointGeoidHeight !== null ? p.pointGeoidHeight : '',
                            p.geoidSystem || '',
                            p.fixMode || ''
                        );
                    }
                    
                    const row = rowData.map(escapeCsvField).join(',');
                    csvContent += row + "\r\n";
                });
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "gnss_survey_data.csv";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            // ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: DXFä¿å­˜ãƒœã‚¿ãƒ³
            document.getElementById('downloadDxfBtn').addEventListener('click', () => {
                if (activePoints.length === 0) {
                    alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                    return;
                }
                const gridIntervalStr = prompt("å¹³é¢å›³ã®ã‚°ãƒªãƒƒãƒ‰é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\nä¸è¦ãªå ´åˆã¯0ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", "10");
                const gridInterval = parseFloat(gridIntervalStr);
                if (isNaN(gridInterval)) {
                    alert("ç„¡åŠ¹ãªæ•°å€¤ã§ã™ã€‚");
                    return;
                }

                const sys = document.getElementById('coordSystem').value;
                const pole = parseFloat(document.getElementById('poleHeight').value);
                const processedPoints = activePoints.map(p => ({ ...p, ...latLonToXY(p.lat, p.lon, sys), correctedEle: p.antennaHeight - pole }));
                
                let dxf = generateDxfHeaderAndTables(false);
                dxf += `0\nSECTION\n2\nENTITIES\n`;
                dxf += generateDxfEntities(processedPoints, gridInterval);
                dxf += `0\nENDSEC\n0\nEOF\n`;
                
                const blob = new Blob([dxf], { type: 'application/dxf' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "plan_view.dxf";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            // æ–­é¢å›³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: CSVä¿å­˜ãƒœã‚¿ãƒ³ (ä¿®æ­£ç‰ˆ)
            document.getElementById('downloadSectionCsvBtn').addEventListener('click', () => {
                if (!currentSectionData || currentSectionData.length === 0) {
                    alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹æ–­é¢ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                    return;
                }
                let csvContent = "\uFEFF"; // Excelç”¨ã®BOM

                // æ–­é¢ç·šåº§æ¨™ã®æ›¸ãå‡ºã—
                if (lastSectionCoords && lastSectionCoords.pathXY && lastSectionCoords.pathXY.length >= 2) {
                    csvContent += "æ–­é¢ç·šåº§æ¨™\r\n";
                    csvContent += "é …ç›®,Yåº§æ¨™(m),Xåº§æ¨™(m)\r\n";
                    const startPoint = lastSectionCoords.pathXY[0];
                    const endPoint = lastSectionCoords.pathXY[lastSectionCoords.pathXY.length - 1];
                    csvContent += `å§‹ç‚¹,${startPoint.x.toFixed(4)},${startPoint.y.toFixed(4)}\r\n`;
                    csvContent += `çµ‚ç‚¹,${endPoint.x.toFixed(4)},${endPoint.y.toFixed(4)}\r\n`;
                    csvContent += "\r\n"; // ç©ºè¡Œã§åŒºåˆ‡ã‚‹
                }

                // æ¸¬ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãå‡ºã—
                const sectionType = document.querySelector('input[name="sectionType"]:checked').value;
                if (sectionType === 'projected') {
                    csvContent += "æ¸¬ç‚¹å,å§‹ç‚¹ã‹ã‚‰ã®è·é›¢(m),è£œæ­£å¾Œæ¨™é«˜(m),å…ƒã®Xåº§æ¨™(m),å…ƒã®Yåº§æ¨™(m)\r\n";
                } else { // connected
                    csvContent += "æ¸¬ç‚¹å,ç´¯ç©è·é›¢(m),è£œæ­£å¾Œæ¨™é«˜(m),å…ƒã®Xåº§æ¨™(m),å…ƒã®Yåº§æ¨™(m)\r\n";
                }
                currentSectionData.forEach(p => {
                    const row = [p.name, p.x.toFixed(4), p.y.toFixed(4), p.originalX.toFixed(4), p.originalY.toFixed(4)].join(',');
                    csvContent += row + "\r\n";
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "section_profile_data.csv";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            // æ–­é¢å›³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: DXFä¿å­˜ãƒœã‚¿ãƒ³
            document.getElementById('downloadSectionDxfBtn').addEventListener('click', () => {
                if (!currentSectionData || currentSectionData.length === 0) {
                    alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹æ–­é¢ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                    return;
                }
                const exportType = document.querySelector('input[name="dxfExportType"]:checked').value;
                const gridIntervalSectionStr = prompt("æ–­é¢å›³ã®ã‚°ãƒªãƒƒãƒ‰é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\nä¸è¦ãªå ´åˆã¯0ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", "1");
                const gridIntervalSection = parseFloat(gridIntervalSectionStr);
                if (isNaN(gridIntervalSection)) {
                    alert("ç„¡åŠ¹ãªæ•°å€¤ã§ã™ã€‚");
                    return;
                }
                
                let dxf = '';
                let fileName = 'section_profile.dxf';

                if (exportType === 'both') {
                    if (activePoints.length === 0) {
                        alert("å¹³é¢å›³ã«å‡ºåŠ›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚\nã€Œæ–­é¢å›³ã®ã¿ã€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
                        return;
                    }
                    const gridIntervalPlanStr = prompt("å¹³é¢å›³ã®ã‚°ãƒªãƒƒãƒ‰é–“éš”(m)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\nä¸è¦ãªå ´åˆã¯0ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", "10");
                    const gridIntervalPlan = parseFloat(gridIntervalPlanStr);
                    if (isNaN(gridIntervalPlan)) {
                        alert("ç„¡åŠ¹ãªæ•°å€¤ã§ã™ã€‚");
                        return;
                    }
                    dxf = generateCombinedDxfContent(gridIntervalPlan, gridIntervalSection);
                    fileName = 'plan_and_section.dxf';
                } else { // section_only
                    dxf = generateDxfHeaderAndTables(false);
                    dxf += `0\nSECTION\n2\nENTITIES\n`;
                    dxf += generateSectionDxfEntities(currentSectionData, gridIntervalSection, 0, 0); 
                    dxf += `0\nENDSEC\n0\nEOF\n`;
                }

                if (dxf) {
                    const blob = new Blob([dxf], { type: 'application/dxf' });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            });

 }
        
        initialize();
    </script>
</body>
</html>